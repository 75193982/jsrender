{"version":3,"sources":["jsrender.js"],"names":["factory","define","amd","isAmd","getDerivedMethod","baseMethod","method","ret","tag","this","prevBase","base","apply","arguments","getMethod","$isFunction","_d","noop","tagHandlersFromProps","tagCtx","prop","props","rHasHandlers","test","retVal","val","dbgBreak","e","baseApply","dbgMode","debugMode","$viewsSettings","_dbgMode","JsViewsError","message","name","$","link","$extend","target","source","$viewsDelimiters","openChars","closeChars","delimOpenChar0","charAt","delimOpenChar1","delimCloseChar0","delimCloseChar1","linkChar","rTag","$sub","RegExp","rTmplString","getView","inner","type","undefined","views","i","l","found","view","root","_","useKey","get","length","parent","getNestedIndex","index","getIndex","getHelper","helper","wrapped","ctx","linkCtx","res","$helpers","_wrp","global","convertVal","converter","onError","value","boundTag","tmpl","bnds","args","data","$views","_tg","inline","bnd","unlinked","tagName","cvt","flow","extendCtx","_er","cvtArgs","convert","onRender","convertArgs","getRsc","error","slice","depends","getDeps","getResource","resourceType","itemName","store","renderTag","parentView","tagCtxs","isUpdate","topView","tagDef","template","tags","attr","parentTag","itemRet","tagCtxCtx","content","callInit","mapDef","thisMap","initialTmpl","parentTmpl","_is","tmpls","render","renderContent","$templates","_ctr","init","fn","arrVws","dataBoundOnly","dataMap","map","parents","parentTags","rendering","src","unmap","tgt","noVws","HTML","$converters","html","View","context","key","contentTmpl","parentView_","self_","self","isArray","id","viewId","linked","indexStr","push","splice","compileChildResources","storeName","resources","resourceName","resource","settings","compile","onStore","jsvStores","compileTag","Tag","baseTag","compiledDef","$tags","prototype","constructor","_parentTmpl","compileTmpl","options","lookupTemplate","currentName","nodeType","elem","document","getElementById","find","innerHTML","getAttribute","tmplAttr","jsvTmpl","tmplName","setAttribute","compiledTmpl","tmplOrMarkup","markup","tmplObject","tmplFn","replace","rEscapeQuotes","$render","Map","getTgt","baseMap","htmlTag","wrapMap","links","rFirstElem","exec","toLowerCase","div","trim","registerStore","storeSettings","theStore","item","thisStore","OBJECT","storeNames","noIteration","isTopRenderCall","prevData","prevIndex","result","isRenderCall","useViews","renderWithViews","$isArray","setItemVar","newCtx","itemVar","newView","childView","itemResult","swapContent","outerOnRender","syntaxError","helpers","it","fallback","Err","isLinkExpr","convertBack","hasElse","pushprecedingContent","shift","loc","substr","rNewLine","blockTagCheck","block","parseTag","all","bind","colon","comment","codeTag","params","slash","closeBlock","pathBindings","ctxProps","paramsArgs","paramsProps","paramsCtxProps","useTrigger","allowCode","rUnescapeQuotes","rTestElseIf","current","substring","stack","pop","parseParams","rBuildHash","onerror","isCtx","keyToken","keyValue","arg","param","hasHandlers","newNode","parsedParam","astTop","buildCode","setPaths","pathsArr","paths","deps","concat","paramStructure","parts","parseTokens","lftPrn0","lftPrn","bound","path","operator","err","eq","path2","prn","comma","lftPrn2","apos","quot","rtPrn","rtPrnDot","prn2","space","full","parsePath","allPath","not","object","viewProperty","pathTokens","leafToken","subPath","bindings","binds","named","bindto","_jsvto","bndCtx","bd","theOb","_jsv","sb","pathStart","parenDepth","expr","exprFn","newOb","aposed","quoted","boundName","bndStack","prm","tmplLinks","indexOf","paramIndex","split","join","rPath","fnCall","rParams","ast","node","hasTag","hasEncoder","getsVal","hasCnvt","useCnvt","tmplBindings","boundOnErrStart","boundOnErrEnd","tagRender","nestedTmpls","nestedTmpl","tagAndElses","nextIsElse","oldCode","isElse","isGetVal","tagCtxFn","tagStart","trigger","tmplBindingKey","templates","converters","code","tmplOptions","debug","Function","_tag","parentContext","getCharEntity","ch","charEntities","charCodeAt","getTargetProps","toJSON","htmlEncode","text","rIsHtml","rHtmlEncode","jsvStoreName","versionNumber","eval","jQuery","rAttrEncode","&","<",">","\u0000","'","\"","`","jsviews","jsv","sub","parse","extend","syntaxErr","_ths","_cnvt","_err","jsrenderPrev","jsrender","Error","hlp","tmplElem","jquery","selector","call","observable","renderFile","__express","isFunction","ob","Array","obj","toString","noConflict","delimiters","if","done","selected","for","finalElse","include","*",":*","dbg","url","encodeURI","exports","module"],"mappings":"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","file":"jsrender.min.js","sourcesContent":["/*! JsRender v1.0.0-beta: http://jsviews.com/#jsrender\r\ninformal pre V1.0 commit counter: 65\r\n**VERSION FOR WEB**\r\nFor NODE.JS see http://jsviews.com/download/jsrender-node.js*/\r\n/*\r\n * Optimized version of jQuery Templates, for rendering to string.\r\n * Does not require jQuery, or HTML DOM\r\n * Integrates with JsViews (http://jsviews.com/#jsviews)\r\n *\r\n * Copyright 2015, Boris Moore\r\n * Released under the MIT License.\r\n */\r\n\r\n//jshint -W018, -W041\r\n\r\n(function (factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\t// Loading from AMD script loader. Register as an anonymous module.\r\n\t\tdefine(factory);\r\n\t} else {\r\n\t\t// Browser using plain <script> tag\r\n\t\tfactory();\r\n\t}\r\n} (function (isAmd) {\r\n\t\"use strict\";\r\n\r\n\t//========================== Top-level vars ==========================\r\n\r\n\tvar versionNumber = \"v1.0.0-beta\",\r\n\r\n\t\t// global is the this object, which is window when running in the usual browser environment.\r\n\t\tglobal = (0, eval)('this'), // jshint ignore:line\r\n\r\n\t\t$ = global.jQuery,\r\n\t\tjsvStoreName, rTag, rTmplString, topView,\r\n\r\n//TODO\ttmplFnsCache = {},\r\n\r\n\t\tdelimOpenChar0 = \"{\", delimOpenChar1 = \"{\", delimCloseChar0 = \"}\", delimCloseChar1 = \"}\", linkChar = \"^\",\r\n\r\n\t\trPath = /^(!*?)(?:null|true|false|\\d[\\d.]*|([\\w$]+|\\.|~([\\w$]+)|#(view|([\\w$]+))?)([\\w$.^]*?)(?:[.[^]([\\w$]+)\\]?)?)$/g,\r\n\t\t//        not                               object     helper    view  viewProperty pathTokens      leafToken\r\n\r\n\t\trParams = /(\\()(?=\\s*\\()|(?:([([])\\s*)?(?:(\\^?)(!*?[#~]?[\\w$.^]+)?\\s*((\\+\\+|--)|\\+|-|&&|\\|\\||===|!==|==|!=|<=|>=|[<>%*:?\\/]|(=))\\s*|(!*?[#~]?[\\w$.^]+)([([])?)|(,\\s*)|(\\(?)\\\\?(?:(')|(\"))|(?:\\s*(([)\\]])(?=\\s*[.^]|\\s*$|[^\\(\\[])|[)\\]])([([]?))|(\\s+)/g,\r\n\t\t//          lftPrn0        lftPrn        bound            path    operator err                                                eq             path2       prn    comma   lftPrn2   apos quot      rtPrn rtPrnDot                           prn2  space\r\n\t\t// (left paren? followed by (path? followed by operator) or (path followed by left paren?)) or comma or apos or quot or right paren or space\r\n\r\n\t\tisRenderCall,\r\n\t\trNewLine = /[ \\t]*(\\r\\n|\\n|\\r)/g,\r\n\t\trUnescapeQuotes = /\\\\(['\"])/g,\r\n\t\trEscapeQuotes = /['\"\\\\]/g, // Escape quotes and \\ character\r\n\t\trBuildHash = /(?:\\x08|^)(onerror:)?(?:(~?)(([\\w$_\\.]+):)?([^\\x08]+))\\x08(,)?([^\\x08]+)/gi,\r\n\t\trTestElseIf = /^if\\s/,\r\n\t\trFirstElem = /<(\\w+)[>\\s]/,\r\n\t\trAttrEncode = /[\\x00`><\"'&]/g, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings\r\n\t\trIsHtml = /[\\x00`><\\\"'&]/,\r\n\t\trHasHandlers = /^on[A-Z]|^convert(Back)?$/,\r\n\t\trHtmlEncode = rAttrEncode,\r\n\t\tviewId = 0,\r\n\t\tcharEntities = {\r\n\t\t\t\"&\": \"&amp;\",\r\n\t\t\t\"<\": \"&lt;\",\r\n\t\t\t\">\": \"&gt;\",\r\n\t\t\t\"\\x00\": \"&#0;\",\r\n\t\t\t\"'\": \"&#39;\",\r\n\t\t\t'\"': \"&#34;\",\r\n\t\t\t\"`\": \"&#96;\"\r\n\t\t},\r\n\t\tHTML = \"html\",\r\n\t\tOBJECT = \"object\",\r\n\t\ttmplAttr = \"data-jsv-tmpl\",\r\n\t\tjsvTmpl = \"jsvTmpl\",\r\n\t\tindexStr = \"For #index in nested block use #getIndex().\",\r\n\t\t$render = {},\r\n\t\tjsvStores = {\r\n\t\t\ttemplate: {\r\n\t\t\t\tcompile: compileTmpl\r\n\t\t\t},\r\n\t\t\ttag: {\r\n\t\t\t\tcompile: compileTag\r\n\t\t\t},\r\n\t\t\thelper: {},\r\n\t\t\tconverter: {}\r\n\t\t},\r\n\r\n\t\t// views object ($.views if jQuery is loaded, jsrender.views if no jQuery, e.g. in Node.js)\r\n\t\t$views = {\r\n\t\t\tjsviews: versionNumber,\r\n\t\t\tsettings: function(settings) {\r\n\t\t\t\t$extend($viewsSettings, settings);\r\n\t\t\t\tdbgMode($viewsSettings._dbgMode);\r\n\t\t\t\tif ($viewsSettings.jsv) {\r\n\t\t\t\t\t$viewsSettings.jsv();\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tsub: {\r\n\t\t\t\t// subscription, e.g. JsViews integration\r\n\t\t\t\tView: View,\r\n\t\t\t\tErr: JsViewsError,\r\n\t\t\t\ttmplFn: tmplFn,\r\n\t\t\t\tparse: parseParams,\r\n\t\t\t\textend: $extend,\r\n\t\t\t\tsyntaxErr: syntaxError,\r\n\t\t\t\tonStore: {},\r\n\t\t\t\t_ths: tagHandlersFromProps,\r\n\t\t\t\t_tg: function() {} // Constructor for tagDef\r\n\t\t\t},\r\n\t\t\tmap: dataMap, // If jsObservable loaded first, use that definition of dataMap\r\n\t\t\t_cnvt: convertVal,\r\n\t\t\t_tag: renderTag,\r\n\t\t\t_err: error\r\n\t\t},\r\n\r\n\t\tjsrenderPrev = global.jsrender;\r\n\r\n\tfunction getDerivedMethod(baseMethod, method) {\r\n\t\treturn function () {\r\n\t\t\tvar ret,\r\n\t\t\t\ttag = this,\r\n\t\t\t\tprevBase = tag.base;\r\n\r\n\t\t\ttag.base = baseMethod; // Within method call, calling this.base will call the base method\r\n\t\t\tret = method.apply(tag, arguments); // Call the method\r\n\t\t\ttag.base = prevBase; // Replace this.base to be the base method of the previous call, for chained calls\r\n\t\t\treturn ret;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction getMethod(baseMethod, method) {\r\n\t\t// For derived methods (or handlers declared declaratively as in {{:foo onChange=~fooChanged}} replace by a derived method, to allow using this.base(...)\r\n\t\t// or this.baseApply(arguments) to call the base implementation. (Equivalent to this._super(...) and this._superApply(arguments) in jQuery UI)\r\n\t\tif ($isFunction(method)) {\r\n\t\t\tmethod = getDerivedMethod(\r\n\t\t\t\t\t!baseMethod\r\n\t\t\t\t\t\t? noop // no base method implementation, so use noop as base method\r\n\t\t\t\t\t\t: baseMethod._d\r\n\t\t\t\t\t\t\t? baseMethod // baseMethod is a derived method, so us it\r\n\t\t\t\t\t\t\t: getDerivedMethod(noop, baseMethod), // baseMethod is not derived so make its base method be the noop method\r\n\t\t\t\t\tmethod\r\n\t\t\t\t);\r\n\t\t\tmethod._d = 1; // Add flag that this is a derived method\r\n\t\t}\r\n\t\treturn method;\r\n\t}\r\n\r\n\tfunction tagHandlersFromProps(tag, tagCtx) {\r\n\t\tfor (var prop in tagCtx.props) {\r\n\t\t\tif (rHasHandlers.test(prop)) {\r\n\t\t\t\ttag[prop] = getMethod(tag[prop], tagCtx.props[prop]);\r\n\t\t\t\t// Copy over the onFoo props, convert and convertBack from tagCtx.props to tag (overrides values in tagDef).\r\n\t\t\t\t// Note: unsupported scenario: if handlers are dynamically added ^onFoo=expression this will work, but dynamically removing will not work.\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction retVal(val) {\r\n\t\treturn val;\r\n\t}\r\n\r\n\tfunction noop() {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tfunction dbgBreak(val) {\r\n\t\t// Usage examples: {{dbg:...}}, {{:~dbg(...)}}, {{for ... onAfterLink=~dbg}}, {{dbg .../}} etc.\r\n\t\t// To break here, stop on caught exceptions.\r\n\t\ttry {\r\n\t\t\tdebugger;\r\n\t\t\tthrow \"dbg breakpoint\";\r\n\t\t}\r\n\t\tcatch (e) {}\r\n\t\treturn this.base ? this.baseApply(arguments) : val;\r\n\t}\r\n\r\n\tfunction dbgMode(debugMode) {\r\n\t\t$viewsSettings._dbgMode = debugMode !== false; // Pass in false to unset. Otherwise sets to true.\r\n\t}\r\n\r\n\tfunction JsViewsError(message) {\r\n\t\t// Error exception type for JsViews/JsRender\r\n\t\t// Override of $.views.sub.Error is possible\r\n\t\tthis.name = ($.link ? \"JsViews\" : \"JsRender\") + \" Error\";\r\n\t\tthis.message = message || this.name;\r\n\t}\r\n\r\n\tfunction $extend(target, source) {\r\n\t\tvar name;\r\n\t\tfor (name in source) {\r\n\t\t\ttarget[name] = source[name];\r\n\t\t}\r\n\t\treturn target;\r\n\t}\r\n\r\n\t(JsViewsError.prototype = new Error()).constructor = JsViewsError;\r\n\r\n\t//========================== Top-level functions ==========================\r\n\r\n\t//===================\r\n\t// views.delimiters\r\n\t//===================\r\n\tfunction $viewsDelimiters(openChars, closeChars, link) {\r\n\t\t// Set the tag opening and closing delimiters and 'link' character. Default is \"{{\", \"}}\" and \"^\"\r\n\t\t// openChars, closeChars: opening and closing strings, each with two characters\r\n\r\n\t\tif (this !== 0 || openChars) {\r\n\t\t\tdelimOpenChar0 = openChars ? openChars.charAt(0) : delimOpenChar0; // Escape the characters - since they could be regex special characters\r\n\t\t\tdelimOpenChar1 = openChars ? openChars.charAt(1) : delimOpenChar1;\r\n\t\t\tdelimCloseChar0 = closeChars ? closeChars.charAt(0) : delimCloseChar0;\r\n\t\t\tdelimCloseChar1 = closeChars ? closeChars.charAt(1) : delimCloseChar1;\r\n\t\t\tlinkChar = link || linkChar;\r\n\t\t\topenChars = \"\\\\\" + delimOpenChar0 + \"(\\\\\" + linkChar + \")?\\\\\" + delimOpenChar1;  // Default is \"{^{\"\r\n\t\t\tcloseChars = \"\\\\\" + delimCloseChar0 + \"\\\\\" + delimCloseChar1;                   // Default is \"}}\"\r\n\t\t\t// Build regex with new delimiters\r\n\t\t\t//          tag    (followed by / space or })   or cvtr+colon or html or code\r\n\t\t\trTag = \"(?:(?:(\\\\w+(?=[\\\\/\\\\s\\\\\" + delimCloseChar0 + \"]))|(?:(\\\\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\\\\*)))\"\r\n\t\t\t\t+ \"\\\\s*((?:[^\\\\\" + delimCloseChar0 + \"]|\\\\\" + delimCloseChar0 + \"(?!\\\\\" + delimCloseChar1 + \"))*?)\";\r\n\r\n\t\t\t// make rTag available to JsViews (or other components) for parsing binding expressions\r\n\t\t\t$sub.rTag = rTag + \")\";\r\n\r\n\t\t\trTag = new RegExp(openChars + rTag + \"(\\\\/)?|(?:\\\\/(\\\\w+)))\" + closeChars, \"g\");\r\n\r\n\t\t\t// Default:    bind           tag       converter colon html     comment            code      params            slash   closeBlock\r\n\t\t\t//           /{(\\^)?{(?:(?:(\\w+(?=[\\/\\s}]))|(?:(\\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\\*)))\\s*((?:[^}]|}(?!}))*?)(\\/)?|(?:\\/(\\w+)))}}/g\r\n\r\n\t\t\trTmplString = new RegExp(\"<.*>|([^\\\\\\\\]|^)[{}]|\" + openChars + \".*\" + closeChars);\r\n\t\t\t// rTmplString looks for html tags or { or } char not preceded by \\\\, or JsRender tags {{xxx}}. Each of these strings are considered\r\n\t\t\t// NOT to be jQuery selectors\r\n\t\t}\r\n\t\treturn [delimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, linkChar];\r\n\t}\r\n\r\n\t//=========\r\n\t// View.get\r\n\t//=========\r\n\r\n\tfunction getView(inner, type) { //view.get(inner, type)\r\n\t\tif (!type) {\r\n\t\t\t// view.get(type)\r\n\t\t\ttype = inner;\r\n\t\t\tinner = undefined;\r\n\t\t}\r\n\r\n\t\tvar views, i, l, found,\r\n\t\t\tview = this,\r\n\t\t\troot = !type || type === \"root\";\r\n\t\t\t// If type is undefined, returns root view (view under top view).\r\n\r\n\t\tif (inner) {\r\n\t\t\t// Go through views - this one, and all nested ones, depth-first - and return first one with given type.\r\n\t\t\tfound = view.type === type ? view : undefined;\r\n\t\t\tif (!found) {\r\n\t\t\t\tviews = view.views;\r\n\t\t\t\tif (view._.useKey) {\r\n\t\t\t\t\tfor (i in views) {\r\n\t\t\t\t\t\tif (found = views[i].get(inner, type)) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfor (i = 0, l = views.length; !found && i < l; i++) {\r\n\t\t\t\t\t\tfound = views[i].get(inner, type);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (root) {\r\n\t\t\t// Find root view. (view whose parent is top view)\r\n\t\t\twhile (view.parent.parent) {\r\n\t\t\t\tfound = view = view.parent;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\twhile (view && !found) {\r\n\t\t\t\t// Go through views - this one, and all parent ones - and return first one with given type.\r\n\t\t\t\tfound = view.type === type ? view : undefined;\r\n\t\t\t\tview = view.parent;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn found;\r\n\t}\r\n\r\n\tfunction getNestedIndex() {\r\n\t\tvar view = this.get(\"item\");\r\n\t\treturn view ? view.index : undefined;\r\n\t}\r\n\r\n\tgetNestedIndex.depends = function() {\r\n\t\treturn [this.get(\"item\"), \"index\"];\r\n\t};\r\n\r\n\tfunction getIndex() {\r\n\t\treturn this.index;\r\n\t}\r\n\r\n\tgetIndex.depends = \"index\";\r\n\r\n\t//==========\r\n\t// View.hlp\r\n\t//==========\r\n\r\n\tfunction getHelper(helper) {\r\n\t\t// Helper method called as view.hlp(key) from compiled template, for helper functions or template parameters ~foo\r\n\t\tvar wrapped,\r\n\t\t\tview = this,\r\n\t\t\tctx = view.linkCtx,\r\n\t\t\tres = (view.ctx || {})[helper];\r\n\r\n\t\tif (res === undefined && ctx && ctx.ctx) {\r\n\t\t\tres = ctx.ctx[helper];\r\n\t\t}\r\n\t\tif (res === undefined) {\r\n\t\t\tres = $helpers[helper];\r\n\t\t}\r\n\r\n\t\tif (res) {\r\n\t\t\tif ($isFunction(res) && !res._wrp) {\r\n\t\t\t\t// If it is of type function, and not already wrapped, we will wrap it, so if called with no this pointer it will be called with the\r\n\t\t\t\t// view as 'this' context. If the helper ~foo() was in a data-link expression, the view will have a 'temporary' linkCtx property too.\r\n\t\t\t\t// Note that helper functions on deeper paths will have specific this pointers, from the preceding path.\r\n\t\t\t\t// For example, ~util.foo() will have the ~util object as 'this' pointer\r\n\t\t\t\twrapped = function() {\r\n\t\t\t\t\treturn res.apply((!this || this === global) ? view : this, arguments);\r\n\t\t\t\t};\r\n\t\t\t\twrapped._wrp = true;\r\n\t\t\t\t$extend(wrapped, res); // Attach same expandos (if any) to the wrapped function\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn wrapped || res;\r\n\t}\r\n\r\n\t//==============\r\n\t// views._cnvt\r\n\t//==============\r\n\r\n\tfunction convertVal(converter, view, tagCtx, onError) {\r\n\t\t// self is template object or linkCtx object\r\n\t\tvar tag, value,\r\n\t\t\t// if tagCtx is an integer, then it is the key for the compiled function to return the boundTag tagCtx\r\n\t\t\tboundTag = typeof tagCtx === \"number\" && view.tmpl.bnds[tagCtx-1],\r\n\t\t\tlinkCtx = view.linkCtx; // For data-link=\"{cvt:...}\"...\r\n\r\n\t\tif (onError !== undefined) {\r\n\t\t\ttagCtx = onError = {props: {}, args: [onError]};\r\n\t\t} else if (boundTag) {\r\n\t\t\ttagCtx = boundTag(view.data, view, $views);\r\n\t\t}\r\n\r\n\t\tvalue = tagCtx.args[0];\r\n\t\tif (converter || boundTag) {\r\n\t\t\ttag = linkCtx && linkCtx.tag;\r\n\t\t\tif (!tag) {\r\n\t\t\t\ttag = $extend(new $sub._tg(), {\r\n\t\t\t\t\t_: {\r\n\t\t\t\t\t\tinline: !linkCtx,\r\n\t\t\t\t\t\tbnd: boundTag,\r\n\t\t\t\t\t\tunlinked: true\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttagName: \":\",\r\n\t\t\t\t\tcvt: converter,\r\n\t\t\t\t\tflow: true,\r\n\t\t\t\t\ttagCtx: tagCtx,\r\n\t\t\t\t});\r\n\t\t\t\tif (linkCtx) {\r\n\t\t\t\t\tlinkCtx.tag = tag;\r\n\t\t\t\t\ttag.linkCtx = linkCtx;\r\n\t\t\t\t}\r\n\t\t\t\ttagCtx.ctx = extendCtx(tagCtx.ctx, (linkCtx ? linkCtx.view : view).ctx);\r\n\t\t\t}\r\n\t\t\ttag._er = onError && value;\r\n\t\t\ttagHandlersFromProps(tag, tagCtx);\r\n\r\n\t\t\ttagCtx.view = view;\r\n\r\n\t\t\ttag.ctx = tagCtx.ctx || {};\r\n\t\t\ttagCtx.ctx = undefined;\r\n\t\t\t// Provide this tag on view, for addBindingMarkers on bound tags to add the tag to view._.bnds, associated with the tag id,\r\n\t\t\tview._.tag = tag;\r\n\r\n\t\t\tvalue = tag.cvtArgs(tag.convert || converter !== \"true\" && converter)[0]; // If there is a convertBack but no convert, converter will be \"true\"\r\n\r\n\t\t\t// Call onRender (used by JsViews if present, to add binding annotations around rendered content)\r\n\t\t\tvalue = boundTag && view._.onRender\r\n\t\t\t\t? view._.onRender(value, view, boundTag)\r\n\t\t\t\t: value;\r\n\t\t\tview._.tag = undefined;\r\n\t\t}\r\n\t\treturn value != undefined ? value : \"\";\r\n\t}\r\n\r\n\tfunction convertArgs(converter) {\r\n\t\tvar tag = this,\r\n\t\t\ttagCtx = tag.tagCtx,\r\n\t\t\tview = tagCtx.view,\r\n\t\t\targs = tagCtx.args;\r\n\r\n\t\tconverter = tag.convert || converter;\r\n\t\tconverter = converter && (\"\" + converter === converter\r\n\t\t\t? (view.getRsc(\"converters\", converter) || error(\"Unknown converter: '\" + converter + \"'\"))\r\n\t\t\t: converter);\r\n\r\n\t\targs = !args.length && !tagCtx.index // On the opening tag with no args, bind to the current data context\r\n\t\t\t? [view.data]\r\n\t\t\t: converter\r\n\t\t\t\t? args.slice() // If there is a converter, use a copy of the tagCtx.args array for rendering, and replace the args[0] in\r\n\t\t\t\t// the copied array with the converted value. But we do not modify the value of tag.tagCtx.args[0] (the original args array)\r\n\t\t\t\t: args; // If no converter, get the original tagCtx.args\r\n\r\n\t\tif (converter) {\r\n\t\t\tif (converter.depends) {\r\n\t\t\t\ttag.depends = $sub.getDeps(tag.depends, tag, converter.depends, converter);\r\n\t\t\t}\r\n\t\t\targs[0] = converter.apply(tag, args);\r\n\t\t}\r\n\t\treturn args;\r\n\t}\r\n\r\n\t//=============\r\n\t// views._tag\r\n\t//=============\r\n\r\n\tfunction getResource(resourceType, itemName) {\r\n\t\tvar res, store,\r\n\t\t\tview = this;\r\n\t\twhile ((res === undefined) && view) {\r\n\t\t\tstore = view.tmpl && view.tmpl[resourceType];\r\n\t\t\tres = store && store[itemName];\r\n\t\t\tview = view.parent;\r\n\t\t}\r\n\t\treturn res || $views[resourceType][itemName];\r\n\t}\r\n\r\n\tfunction renderTag(tagName, parentView, tmpl, tagCtxs, isUpdate, onError) {\r\n\t\tparentView = parentView || topView;\r\n\t\tvar tag, tag_, tagDef, template, tags, attr, parentTag, i, l, itemRet, tagCtx, tagCtxCtx, content, callInit, mapDef, thisMap, args, props, initialTmpl,\r\n\t\t\tret = \"\",\r\n\t\t\tlinkCtx = parentView.linkCtx || 0,\r\n\t\t\tctx = parentView.ctx,\r\n\t\t\tparentTmpl = tmpl || parentView.tmpl,\r\n\t\t\t// if tagCtx is an integer, then it is the key for the compiled function to return the boundTag tagCtxs\r\n\t\t\tboundTag = typeof tagCtxs === \"number\" && parentView.tmpl.bnds[tagCtxs-1];\r\n\r\n\t\tif (tagName._is === \"tag\") {\r\n\t\t\ttag = tagName;\r\n\t\t\ttagName = tag.tagName;\r\n\t\t\ttagCtxs = tag.tagCtxs;\r\n\t\t\ttemplate = tag.template;\r\n\t\t} else {\r\n\t\t\ttagDef = parentView.getRsc(\"tags\", tagName) || error(\"Unknown tag: {{\" + tagName + \"}} \");\r\n\t\t\ttemplate = tagDef.template;\r\n\t\t}\r\n\r\n\t\tif (onError !== undefined) {\r\n\t\t\tret += onError;\r\n\t\t\ttagCtxs = onError = [{props: {}, args: []}];\r\n\t\t} else if (boundTag) {\r\n\t\t\ttagCtxs = boundTag(parentView.data, parentView, $views);\r\n\t\t}\r\n\r\n\t\tl = tagCtxs.length;\r\n\t\tfor (i = 0; i < l; i++) {\r\n\t\t\ttagCtx = tagCtxs[i];\r\n\t\t\tif (!linkCtx || !linkCtx.tag || i && !linkCtx.tag._.inline || tag._er) {\r\n\t\t\t\t// Initialize tagCtx\r\n\t\t\t\t// For block tags, tagCtx.tmpl is an integer > 0\r\n\t\t\t\tif (content = tagCtx.tmpl) {\r\n\t\t\t\t\tcontent = tagCtx.content = parentTmpl.tmpls[content - 1];\r\n\t\t\t\t}\r\n\t\t\t\ttagCtx.index = i;\r\n\t\t\t\ttagCtx.tmpl = template || content; // Set the tmpl property to the content of the block tag\r\n\t\t\t\ttagCtx.render = renderContent;\r\n\t\t\t\ttagCtx.view = parentView;\r\n\t\t\t\ttagCtx.ctx = extendCtx(tagCtx.ctx, ctx); // Clone and extend parentView.ctx\r\n\t\t\t}\r\n\t\t\tif (tmpl = tagCtx.props.tmpl) {\r\n\t\t\t\t// If the tmpl property is overridden, set the value (when initializing, or, in case of binding: ^tmpl=..., when updating)\r\n\t\t\t\ttmpl = \"\" + tmpl === tmpl // if a string\r\n\t\t\t\t\t? parentView.getRsc(\"templates\", tmpl) || $templates(tmpl)\r\n\t\t\t\t\t: tmpl;\r\n\r\n\t\t\t\ttagCtx.tmpl = tmpl;\r\n\t\t\t}\r\n\r\n\t\t\tif (!tag) {\r\n\t\t\t\t// This will only be hit for initial tagCtx (not for {{else}}) - if the tag instance does not exist yet\r\n\t\t\t\t// Instantiate tag if it does not yet exist\r\n\t\t\t\t// If the tag has not already been instantiated, we will create a new instance.\r\n\t\t\t\t// ~tag will access the tag, even within the rendering of the template content of this tag.\r\n\t\t\t\t// From child/descendant tags, can access using ~tag.parent, or ~parentTags.tagName\r\n\t\t\t\ttag = new tagDef._ctr();\r\n\t\t\t\tcallInit = !!tag.init;\r\n\r\n\t\t\t\ttag.parent = parentTag = ctx && ctx.tag;\r\n\t\t\t\ttag.tagCtxs = tagCtxs;\r\n\r\n\t\t\t\tif (linkCtx) {\r\n\t\t\t\t\ttag._.inline = false;\r\n\t\t\t\t\tlinkCtx.tag = tag;\r\n\t\t\t\t\ttag.linkCtx = linkCtx;\r\n\t\t\t\t}\r\n\t\t\t\tif (tag._.bnd = boundTag || linkCtx.fn) {\r\n\t\t\t\t\t// Bound if {^{tag...}} or data-link=\"{tag...}\"\r\n\t\t\t\t\ttag._.arrVws = {};\r\n\t\t\t\t} else if (tag.dataBoundOnly) {\r\n\t\t\t\t\terror(\"{^{\" + tagName + \"}} tag must be data-bound\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//TODO better perf for childTags() - keep child tag.tags array, (and remove child, when disposed)\r\n\t\t\t\t// tag.tags = [];\r\n\t\t\t}\r\n\t\t\ttagCtx.tag = tag;\r\n\t\t\tif (tag.dataMap && tag.tagCtxs) {\r\n\t\t\t\ttagCtx.map = tag.tagCtxs[i].map; // Copy over the compiled map instance from the previous tagCtxs to the refreshed ones\r\n\t\t\t}\r\n\t\t\tif (!tag.flow) {\r\n\t\t\t\ttagCtxCtx = tagCtx.ctx = tagCtx.ctx || {};\r\n\r\n\t\t\t\t// tags hash: tag.ctx.tags, merged with parentView.ctx.tags,\r\n\t\t\t\ttags = tag.parents = tagCtxCtx.parentTags = ctx && extendCtx(tagCtxCtx.parentTags, ctx.parentTags) || {};\r\n\t\t\t\tif (parentTag) {\r\n\t\t\t\t\ttags[parentTag.tagName] = parentTag;\r\n\t\t\t\t\t//TODO better perf for childTags: parentTag.tags.push(tag);\r\n\t\t\t\t}\r\n\t\t\t\ttags[tag.tagName] = tagCtxCtx.tag = tag;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (boundTag || linkCtx) {\r\n\t\t\t// Provide this tag on view, for addBindingMarkers on bound tags to add the tag to view._.bnds, associated with the tag id\r\n\t\t\tparentView._.tag = tag;\r\n\t\t}\r\n\t\tif (!(tag._er = onError)) {\r\n\t\t\ttagHandlersFromProps(tag, tagCtxs[0]);\r\n\t\t\ttag.rendering = {}; // Provide object for state during render calls to tag and elses. (Used by {{if}} and {{for}}...)\r\n\t\t\tfor (i = 0; i < l; i++) {\r\n\t\t\t\ttagCtx = tag.tagCtx = tag.tagCtxs[i];\r\n\t\t\t\tprops = tagCtx.props;\r\n\t\t\t\targs = tag.cvtArgs();\r\n\r\n\t\t\t\tif (mapDef = props.dataMap || tag.dataMap) {\r\n\t\t\t\t\tif (args.length || props.dataMap) {\r\n\t\t\t\t\t\tthisMap = tagCtx.map;\r\n\t\t\t\t\t\tif (!thisMap || thisMap.src !== args[0] || isUpdate) {\r\n\t\t\t\t\t\t\tif (thisMap && thisMap.src) {\r\n\t\t\t\t\t\t\t\tthisMap.unmap(); // only called if observable map - not when only used in JsRender, e.g. by {{props}}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthisMap = tagCtx.map = mapDef.map(args[0], props);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\targs = [thisMap.tgt];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\ttag.ctx = tagCtx.ctx;\r\n\r\n\t\t\t\tif (!i) {\r\n\t\t\t\t\tif (callInit) {\r\n\t\t\t\t\t\tinitialTmpl = tag.template;\r\n\t\t\t\t\t\ttag.init(tagCtx, linkCtx, tag.ctx);\r\n\t\t\t\t\t\tcallInit = undefined;\r\n\t\t\t\t\t\tif (tag.template !== initialTmpl) {\r\n\t\t\t\t\t\t\ttag._.tmpl = tag.template; // This will override the tag.template and also tagCtx.props.tmpl for all tagCtxs\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (linkCtx) {\r\n\t\t\t\t\t\t// Set attr on linkCtx to ensure outputting to the correct target attribute.\r\n\t\t\t\t\t\t// Setting either linkCtx.attr or this.attr in the init() allows per-instance choice of target attrib.\r\n\t\t\t\t\t\tlinkCtx.attr = tag.attr = linkCtx.attr || tag.attr;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tattr = tag.attr;\r\n\t\t\t\t\ttag._.noVws = attr && attr !== HTML;\r\n\t\t\t\t}\r\n\r\n\t\t\t\titemRet = undefined;\r\n\t\t\t\tif (tag.render) {\r\n\t\t\t\t\titemRet = tag.render.apply(tag, args);\r\n\t\t\t\t}\r\n\t\t\t\tif (!args.length) {\r\n\t\t\t\t\targs = [parentView]; // no arguments - get data context from view.\r\n\t\t\t\t}\r\n\t\t\t\tif (itemRet === undefined) {\r\n\t\t\t\t\titemRet = tagCtx.render(args.length ? args[0] : parentView, true) || (isUpdate ? undefined : \"\");\r\n\t\t\t\t}\r\n\t\t\t\t// No return value from render, and no template/content tagCtx.render(...), so return undefined\r\n\t\t\t\tret = ret ? ret + (itemRet || \"\") : itemRet; // If no rendered content, this will be undefined\r\n\t\t\t}\r\n\t\t\ttag.rendering = undefined;\r\n\t\t}\r\n\t\ttag.tagCtx = tag.tagCtxs[0];\r\n\t\ttag.ctx = tag.tagCtx.ctx;\r\n\r\n\t\tif (tag._.noVws) {\r\n\t\t\t if (tag._.inline) {\r\n\t\t\t\t// inline tag with attr set to \"text\" will insert HTML-encoded content - as if it was element-based innerText\r\n\t\t\t\tret = attr === \"text\"\r\n\t\t\t\t\t? $converters.html(ret)\r\n\t\t\t\t\t: \"\";\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn boundTag && parentView._.onRender\r\n\t\t\t// Call onRender (used by JsViews if present, to add binding annotations around rendered content)\r\n\t\t\t? parentView._.onRender(ret, parentView, boundTag)\r\n\t\t\t: ret;\r\n\t}\r\n\r\n\t//=================\r\n\t// View constructor\r\n\t//=================\r\n\r\n\tfunction View(context, type, parentView, data, template, key, contentTmpl, onRender) {\r\n\t\t// Constructor for view object in view hierarchy. (Augmented by JsViews if JsViews is loaded)\r\n\t\tvar views, parentView_, tag, self_,\r\n\t\t\tself = this,\r\n\t\t\tisArray = type === \"array\";\r\n\r\n\t\tself.content = contentTmpl;\r\n\t\tself.views = isArray ? [] : {};\r\n\t\tself.parent = parentView;\r\n\t\tself.type = type || \"top\";\r\n\t\tself.data = data;\r\n\t\tself.tmpl = template;\r\n\t\t// If the data is an array, this is an 'array view' with a views array for each child 'item view'\r\n\t\t// If the data is not an array, this is an 'item view' with a views 'hash' object for any child nested views\r\n\t\t// ._.useKey is non zero if is not an 'array view' (owning a data array). Use this as next key for adding to child views hash\r\n\t\t self_ = self._ = {\r\n\t\t\tkey: 0,\r\n\t\t\tuseKey: isArray ? 0 : 1,\r\n\t\t\tid: \"\" + viewId++,\r\n\t\t\tonRender: onRender,\r\n\t\t\tbnds: {}\r\n\t\t};\r\n\t\tself.linked = !!onRender;\r\n\t\tif (parentView) {\r\n\t\t\tviews = parentView.views;\r\n\t\t\tparentView_ = parentView._;\r\n\t\t\tif (parentView_.useKey) {\r\n\t\t\t\t// Parent is an 'item view'. Add this view to its views object\r\n\t\t\t\t// self._key = is the key in the parent view hash\r\n\t\t\t\tviews[self_.key = \"_\" + parentView_.useKey++] = self;\r\n\t\t\t\tself.index = indexStr;\r\n\t\t\t\tself.getIndex = getNestedIndex;\r\n\t\t\t\ttag = parentView_.tag;\r\n\t\t\t\tself_.bnd = isArray && (!tag || !!tag._.bnd && tag); // For array views that are data bound for collection change events, set the\r\n\t\t\t\t// view._.bnd property to true for top-level link() or data-link=\"{for}\", or to the tag instance for a data-bound tag, e.g. {^{for ...}}\r\n\t\t\t} else if (views.length === (self_.key = self.index = key)) { // Parent is an 'array view'. Add this view to its views array\r\n\t\t\t\tviews.push(self); // Use push when possible (better perf than splice)\r\n\t\t\t} else {\r\n\t\t\t\tviews.splice(key, 0, self);\r\n\t\t\t}\r\n\t\t\t// If no context was passed in, use parent context\r\n\t\t\t// If context was passed in, it should have been merged already with parent context\r\n\t\t\tself.ctx = context || parentView.ctx;\r\n\t\t} else {\r\n\t\t\tself.ctx = context;\r\n\t\t}\r\n\t}\r\n\r\n\tView.prototype = {\r\n\t\tget: getView,\r\n\t\tgetIndex: getIndex,\r\n\t\tgetRsc: getResource,\r\n\t\thlp: getHelper,\r\n\t\t_is: \"view\"\r\n\t};\r\n\r\n\t//=============\r\n\t// Registration\r\n\t//=============\r\n\r\n\tfunction compileChildResources(parentTmpl) {\r\n\t\tvar storeName, resources, resourceName, resource, settings, compile, onStore;\r\n\t\tfor (storeName in jsvStores) {\r\n\t\t\tsettings = jsvStores[storeName];\r\n\t\t\tif ((compile = settings.compile) && (resources = parentTmpl[storeName + \"s\"])) {\r\n\t\t\t\tfor (resourceName in resources) {\r\n\t\t\t\t\t// compile child resource declarations (templates, tags, tags[\"for\"] or helpers)\r\n\t\t\t\t\tresource = resources[resourceName] = compile(resourceName, resources[resourceName], parentTmpl, 0);\r\n\t\t\t\t\tresource._is = storeName; // Only do this for compiled objects (tags, templates...)\r\n\t\t\t\t\tif (resource && (onStore = $sub.onStore[storeName])) {\r\n\t\t\t\t\t\t// e.g. JsViews integration\r\n\t\t\t\t\t\tonStore(resourceName, resource, compile);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction compileTag(name, tagDef, parentTmpl) {\r\n\t\tvar tmpl, baseTag, prop,\r\n\t\t\tcompiledDef = new $sub._tg();\r\n\r\n\t\tfunction Tag() {\r\n\t\t\tvar tag = this;\r\n\t\t\ttag._ = {\r\n\t\t\t\tinline: true,\r\n\t\t\t\tunlinked: true\r\n\t\t\t};\r\n\r\n\t\t\ttag.tagName = name;\r\n\t\t}\r\n\r\n\t\tif ($isFunction(tagDef)) {\r\n\t\t\t// Simple tag declared as function. No presenter instantation.\r\n\t\t\ttagDef = {\r\n\t\t\t\tdepends: tagDef.depends,\r\n\t\t\t\trender: tagDef\r\n\t\t\t};\r\n\t\t} else if (\"\" + tagDef === tagDef) {\r\n\t\t\ttagDef = {template:  tagDef};\r\n\t\t}\r\n\t\tif (baseTag = tagDef.baseTag) {\r\n\t\t\ttagDef.flow = !!tagDef.flow; // Set flow property, so defaults to false even if baseTag has flow=true\r\n\t\t\ttagDef.baseTag = baseTag = \"\" + baseTag === baseTag\r\n\t\t\t\t? (parentTmpl && parentTmpl.tags[baseTag] || $tags[baseTag])\r\n\t\t\t\t: baseTag;\r\n\r\n\t\t\tcompiledDef = $extend(compiledDef, baseTag);\r\n\r\n\t\t\tfor (prop in tagDef) {\r\n\t\t\t\tcompiledDef[prop] = getMethod(baseTag[prop], tagDef[prop]);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tcompiledDef = $extend(compiledDef, tagDef);\r\n\t\t}\r\n\r\n\t\t// Tag declared as object, used as the prototype for tag instantiation (control/presenter)\r\n\t\tif ((tmpl = compiledDef.template) !== undefined) {\r\n\t\t\tcompiledDef.template = \"\" + tmpl === tmpl ? ($templates[tmpl] || $templates(tmpl)) : tmpl;\r\n\t\t}\r\n\t\tif (compiledDef.init !== false) {\r\n\t\t\t// Set init: false on tagDef if you want to provide just a render method, or render and template, but no constuctor or prototype.\r\n\t\t\t// so equivalent to setting tag to render function, except you can also provide a template.\r\n\t\t\t(Tag.prototype = compiledDef).constructor = compiledDef._ctr = Tag;\r\n\t\t}\r\n\r\n\t\tif (parentTmpl) {\r\n\t\t\tcompiledDef._parentTmpl = parentTmpl;\r\n\t\t}\r\n\t\treturn compiledDef;\r\n\t}\r\n\r\n\tfunction baseApply(args) {\r\n\t\t// In derived method (or handler declared declaratively as in {{:foo onChange=~fooChanged}} can call base method,\r\n\t\t// using this.baseApply(arguments) (Equivalent to this._superApply(arguments) in jQuery UI)\r\n\t\treturn this.base.apply(this, args);\r\n\t}\r\n\r\n\tfunction compileTmpl(name, tmpl, parentTmpl, options) {\r\n\t\t// tmpl is either a template object, a selector for a template script block, the name of a compiled template, or a template object\r\n\r\n\t\t//==== nested functions ====\r\n\t\tfunction lookupTemplate(value) {\r\n\t\t\t// If value is of type string - treat as selector, or name of compiled template\r\n\t\t\t// Return the template object, if already compiled, or the markup string\r\n\t\t\tvar currentName, tmpl;\r\n\t\t\tif ((\"\" + value === value) || value.nodeType > 0 && (elem = value)) {\r\n\t\t\t\tif (!elem) {\r\n\t\t\t\t\tif (/^\\.\\/[^\\\\:*?\"<>]*$/.test(value)) {\r\n\t\t\t\t\t\t// tmpl=\"./some/file.html\"\r\n\t\t\t\t\t\t// If the template is not named, use \"./some/file.html\" as name.\r\n\t\t\t\t\t\tif (tmpl = $templates[name = name || value]) {\r\n\t\t\t\t\t\t\tvalue = tmpl;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// BROWSER-SPECIFIC CODE (not on Node.js):\r\n\t\t\t\t\t\t\t// Look for server-generated script block with id \"./some/file.html\"\r\n\t\t\t\t\t\t\telem = document.getElementById(value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if ($.fn && !rTmplString.test(value)) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\telem = $(document).find(value)[0]; // if jQuery is loaded, test for selector returning elements, and get first element\r\n\t\t\t\t\t\t} catch (e) {}\r\n\t\t\t\t\t}// END BROWSER-SPECIFIC CODE\r\n\t\t\t\t} //BROWSER-SPECIFIC CODE\r\n\t\t\t\tif (elem) {\r\n\t\t\t\t\t// Generally this is a script element.\r\n\t\t\t\t\t// However we allow it to be any element, so you can for example take the content of a div,\r\n\t\t\t\t\t// use it as a template, and replace it by the same content rendered against data.\r\n\t\t\t\t\t// e.g. for linking the content of a div to a container, and using the initial content as template:\r\n\t\t\t\t\t// $.link(\"#content\", model, {tmpl: \"#content\"});\r\n\t\t\t\t\tif (options) {\r\n\t\t\t\t\t\t// We will compile a new template using the markup in the script element\r\n\t\t\t\t\t\tvalue = elem.innerHTML;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// We will cache a single copy of the compiled template, and associate it with the name\r\n\t\t\t\t\t\t// (renaming from a previous name if there was one).\r\n\t\t\t\t\t\tcurrentName = elem.getAttribute(tmplAttr);\r\n\t\t\t\t\t\tif (currentName) {\r\n\t\t\t\t\t\t\tif (currentName !== jsvTmpl) {\r\n\t\t\t\t\t\t\t\tvalue = $templates[currentName];\r\n\t\t\t\t\t\t\t\tdelete $templates[currentName];\r\n\t\t\t\t\t\t\t} else if ($.fn) {\r\n\t\t\t\t\t\t\t\tvalue = $.data(elem)[jsvTmpl];\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tname = name || ($.fn ? jsvTmpl : value);\r\n\t\t\t\t\t\t\tvalue = compileTmpl(name, elem.innerHTML, parentTmpl, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalue.tmplName = name = name || currentName;\r\n\t\t\t\t\t\tif (name !== jsvTmpl) {\r\n\t\t\t\t\t\t\t$templates[name] = value;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telem.setAttribute(tmplAttr, name);\r\n\t\t\t\t\t\tif ($.fn) {\r\n\t\t\t\t\t\t\t$.data(elem, jsvTmpl, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} // END BROWSER-SPECIFIC CODE\r\n\t\t\t\telem = undefined;\r\n\t\t\t} else if (!value.fn) {\r\n\t\t\t\tvalue = undefined;\r\n\t\t\t\t// If value is not a string. HTML element, or compiled template, return undefined\r\n\t\t\t}\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tvar elem, compiledTmpl,\r\n\t\t\ttmplOrMarkup = tmpl = tmpl || \"\";\r\n\r\n\t\t//==== Compile the template ====\r\n\t\tif (options === 0) {\r\n\t\t\toptions = undefined;\r\n\t\t\ttmplOrMarkup = lookupTemplate(tmplOrMarkup); // Top-level compile so do a template lookup\r\n\t\t}\r\n\r\n\t\t// If options, then this was already compiled from a (script) element template declaration.\r\n\t\t// If not, then if tmpl is a template object, use it for options\r\n\t\toptions = options || (tmpl.markup ? tmpl : {});\r\n\t\toptions.tmplName = name;\r\n\t\tif (parentTmpl) {\r\n\t\t\toptions._parentTmpl = parentTmpl;\r\n\t\t}\r\n\t\t// If tmpl is not a markup string or a selector string, then it must be a template object\r\n\t\t// In that case, get it from the markup property of the object\r\n\t\tif (!tmplOrMarkup && tmpl.markup && (tmplOrMarkup = lookupTemplate(tmpl.markup))) {\r\n\t\t\tif (tmplOrMarkup.fn) {\r\n\t\t\t\t// If the string references a compiled template object, need to recompile to merge any modified options\r\n\t\t\t\ttmplOrMarkup = tmplOrMarkup.markup;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (tmplOrMarkup !== undefined) {\r\n\t\t\tif (tmplOrMarkup.fn || tmpl.fn) {\r\n\t\t\t\t// tmpl is already compiled, so use it\r\n\t\t\t\tif (tmplOrMarkup.fn) {\r\n\t\t\t\t\tcompiledTmpl = tmplOrMarkup;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// tmplOrMarkup is a markup string, not a compiled template\r\n\t\t\t\t// Create template object\r\n\t\t\t\ttmpl = tmplObject(tmplOrMarkup, options);\r\n\t\t\t\t// Compile to AST and then to compiled function\r\n\t\t\t\ttmplFn(tmplOrMarkup.replace(rEscapeQuotes, \"\\\\$&\"), tmpl);\r\n\t\t\t}\r\n\t\t\tif (!compiledTmpl) {\r\n\t\t\t\tcompileChildResources(options);\r\n\r\n\t\t\t\tcompiledTmpl = $extend(function() {\r\n\t\t\t\t\treturn tmpl.render.apply(tmpl, arguments);\r\n\t\t\t\t}, tmpl);\r\n\t\t\t}\r\n\t\t\tif (name && !parentTmpl && name !== jsvTmpl) {\r\n\t\t\t\t$render[name] = compiledTmpl;\r\n\t\t\t}\r\n\t\t\treturn compiledTmpl;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction dataMap(mapDef) {\r\n\t\tfunction Map(source, options) {\r\n\t\t\tthis.tgt = mapDef.getTgt(source, options);\r\n\t\t}\r\n\r\n\t\tif ($isFunction(mapDef)) {\r\n\t\t\t// Simple map declared as function\r\n\t\t\tmapDef = {\r\n\t\t\t\tgetTgt: mapDef\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (mapDef.baseMap) {\r\n\t\t\tmapDef = $extend($extend({}, mapDef.baseMap), mapDef);\r\n\t\t}\r\n\r\n\t\tmapDef.map = function(source, options) {\r\n\t\t\treturn new Map(source, options);\r\n\t\t};\r\n\t\treturn mapDef;\r\n\t}\r\n\r\n\t//==== /end of function compile ====\r\n\r\n\tfunction tmplObject(markup, options) {\r\n\t\t// Template object constructor\r\n\t\tvar htmlTag,\r\n\t\t\twrapMap = $viewsSettings.wrapMap || {}, // Only used in JsViews. Otherwise empty: {}\r\n\t\t\ttmpl = $extend(\r\n\t\t\t\t{\r\n\t\t\t\t\ttmpls: [],\r\n\t\t\t\t\tlinks: {}, // Compiled functions for link expressions\r\n\t\t\t\t\tbnds: [],\r\n\t\t\t\t\t_is: \"template\",\r\n\t\t\t\t\trender: renderContent\r\n\t\t\t\t},\r\n\t\t\t\toptions\r\n\t\t\t);\r\n\r\n\t\ttmpl.markup = markup;\r\n\t\tif (!options.htmlTag) {\r\n\t\t\t// Set tmpl.tag to the top-level HTML tag used in the template, if any...\r\n\t\t\thtmlTag = rFirstElem.exec(markup);\r\n\t\t\ttmpl.htmlTag = htmlTag ? htmlTag[1].toLowerCase() : \"\";\r\n\t\t}\r\n\t\thtmlTag = wrapMap[tmpl.htmlTag];\r\n\t\tif (htmlTag && htmlTag !== wrapMap.div) {\r\n\t\t\t// When using JsViews, we trim templates which are inserted into HTML contexts where text nodes are not rendered (i.e. not 'Phrasing Content').\r\n\t\t\t// Currently not trimmed for <li> tag. (Not worth adding perf cost)\r\n\t\t\ttmpl.markup = $.trim(tmpl.markup);\r\n\t\t}\r\n\r\n\t\treturn tmpl;\r\n\t}\r\n\r\n\tfunction registerStore(storeName, storeSettings) {\r\n\r\n\t\tfunction theStore(name, item, parentTmpl) {\r\n\t\t\t// The store is also the function used to add items to the store. e.g. $.templates, or $.views.tags\r\n\r\n\t\t\t// For store of name 'thing', Call as:\r\n\t\t\t//    $.views.things(items[, parentTmpl]),\r\n\t\t\t// or $.views.things(name, item[, parentTmpl])\r\n\r\n\t\t\tvar onStore, compile, itemName, thisStore;\r\n\r\n\t\t\tif (name && typeof name === OBJECT && !name.nodeType && !name.markup && !name.getTgt) {\r\n\t\t\t\t// Call to $.views.things(items[, parentTmpl]),\r\n\r\n\t\t\t\t// Adding items to the store\r\n\t\t\t\t// If name is a hash, then item is parentTmpl. Iterate over hash and call store for key.\r\n\t\t\t\tfor (itemName in name) {\r\n\t\t\t\t\ttheStore(itemName, name[itemName], item);\r\n\t\t\t\t}\r\n\t\t\t\treturn $views;\r\n\t\t\t}\r\n\t\t\t// Adding a single unnamed item to the store\r\n\t\t\tif (item === undefined) {\r\n\t\t\t\titem = name;\r\n\t\t\t\tname = undefined;\r\n\t\t\t}\r\n\t\t\tif (name && \"\" + name !== name) { // name must be a string\r\n\t\t\t\tparentTmpl = item;\r\n\t\t\t\titem = name;\r\n\t\t\t\tname = undefined;\r\n\t\t\t}\r\n\t\t\tthisStore = parentTmpl ? parentTmpl[storeNames] = parentTmpl[storeNames] || {} : theStore;\r\n\t\t\tcompile = storeSettings.compile;\r\n\t\t\tif (item === null) {\r\n\t\t\t\t// If item is null, delete this entry\r\n\t\t\t\tif (name) {\r\n\t\t\t\t\tdelete thisStore[name];\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\titem = compile ? compile(name, item, parentTmpl, 0) : item;\r\n\t\t\t\tif (name) {\r\n\t\t\t\t\tthisStore[name] = item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (compile && item) {\r\n\t\t\t\titem._is = storeName; // Only do this for compiled objects (tags, templates...)\r\n\t\t\t}\r\n\t\t\tif (item && (onStore = $sub.onStore[storeName])) {\r\n\t\t\t\t// e.g. JsViews integration\r\n\t\t\t\tonStore(name, item, compile);\r\n\t\t\t}\r\n\t\t\treturn item;\r\n\t\t}\r\n\r\n\t\tvar storeNames = storeName + \"s\";\r\n\r\n\t\t$views[storeNames] = theStore;\r\n\t}\r\n\r\n\t//==============\r\n\t// renderContent\r\n\t//==============\r\n\r\n\tfunction renderContent(data, context, noIteration, parentView, key, onRender) {\r\n\t\tvar i, l, tag, tmpl, tagCtx, isTopRenderCall, prevData, prevIndex,\r\n\t\t\tview = parentView,\r\n\t\t\tresult = \"\";\r\n\r\n\t\tif (context === true) {\r\n\t\t\tnoIteration = context; // passing boolean as second param - noIteration\r\n\t\t\tcontext = undefined;\r\n\t\t} else if (typeof context !== OBJECT) {\r\n\t\t\tcontext = undefined; // context must be a boolean (noIteration) or a plain object\r\n\t\t}\r\n\r\n\t\tif (tag = this.tag) {\r\n\t\t\t// This is a call from renderTag or tagCtx.render(...)\r\n\t\t\ttagCtx = this;\r\n\t\t\ttmpl = tag._.tmpl || tagCtx.tmpl;\r\n\t\t\tview = view || tagCtx.view;\r\n\t\t\tif (!arguments.length) {\r\n\t\t\t\tdata = view;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// This is a template.render(...) call\r\n\t\t\ttmpl = this;\r\n\t\t}\r\n\r\n\t\tif (tmpl) {\r\n\t\t\tif (!view && data && data._is === \"view\") {\r\n\t\t\t\tview = data; // When passing in a view to render or link (and not passing in a parent view) use the passed-in view as parentView\r\n\t\t\t}\r\n\r\n\t\t\tif (view) {\r\n\t\t\t\tif (data === view) {\r\n\t\t\t\t\t// Inherit the data from the parent view.\r\n\t\t\t\t\t// This may be the contents of an {{if}} block\r\n\t\t\t\t\tdata = view.data;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!tmpl.fn) {\r\n\t\t\t\t// Template has not been compiled yet, so compile it.\r\n\t\t\t\ttmpl = tag._.tmpl = $templates[tmpl] || $templates(tmpl);\r\n\t\t\t}\r\n\r\n\t\t\tisRenderCall = isRenderCall || (isTopRenderCall = !view);\r\n\t\t\tif (!view) {\r\n\t\t\t\t(context = context || {}).root = data; // Provide ~root as shortcut to top-level data.\r\n\t\t\t}\r\n\t\t\tif (!isRenderCall || tmpl.useViews) {\r\n\t\t\t\tresult = renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag);\r\n\t\t\t} else {\r\n\t\t\t\tif (view) { // In a block\r\n\t\t\t\t\tprevData = view.data;\r\n\t\t\t\t\tprevIndex = view.index;\r\n\t\t\t\t\tview.index = indexStr;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tview = topView;\r\n\t\t\t\t\tview.data = data;\r\n\t\t\t\t\tview.ctx = context;\r\n\t\t\t\t}\r\n\t\t\t\tif ($isArray(data) && !noIteration) {\r\n\t\t\t\t\t// Create a view for the array, whose child views correspond to each data item. (Note: if key and parentView are passed in\r\n\t\t\t\t\t// along with parent view, treat as insert -e.g. from view.addViews - so parentView is already the view item for array)\r\n\t\t\t\t\tfor (i = 0, l = data.length; i < l; i++) {\r\n\t\t\t\t\t\tview.index = i;\r\n\t\t\t\t\t\tview.data = data[i];\r\n\t\t\t\t\t\tresult += tmpl.fn(data[i], view, $views);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult += tmpl.fn(data, view, $views);\r\n\t\t\t\t}\r\n\t\t\t\tview.data = prevData;\r\n\t\t\t\tview.index = prevIndex;\r\n\t\t\t}\r\n\t\t\tif (isTopRenderCall) {\r\n\t\t\t\tisRenderCall = undefined;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag) {\r\n\t\tfunction setItemVar(item) {\r\n\t\t\t// When itemVar is specified, set modified ctx with user-named ~item\r\n\t\t\tnewCtx = $extend({}, context);\r\n\t\t\tnewCtx[itemVar] = item;\r\n\t\t}\r\n\r\n\t\t// Render template against data as a tree of subviews (nested rendered template instances), or as a string (top-level template).\r\n\t\t// If the data is the parent view, treat as noIteration, re-render with the same data context.\r\n\t\tvar i, l, newView, childView, itemResult, swapContent, contentTmpl, outerOnRender, tmplName, itemVar, newCtx, tagCtx,\r\n\t\t\tresult=\"\" ;\r\n\r\n\t\tif (tag) {\r\n\t\t\t// This is a call from renderTag or tagCtx.render(...)\r\n\t\t\ttmplName = tag.tagName;\r\n\t\t\ttagCtx = tag.tagCtx;\r\n\t\t\tcontext = context ? extendCtx(context, tag.ctx) : tag.ctx;\r\n\t\t\tcontentTmpl = tagCtx.content;\r\n\t\t\tif (tagCtx.props.link === false) {\r\n\t\t\t\t// link=false setting on block tag\r\n\t\t\t\t// We will override inherited value of link by the explicit setting link=false taken from props\r\n\t\t\t\t// The child views of an unlinked view are also unlinked. So setting child back to true will not have any effect.\r\n\t\t\t\tcontext = context || {};\r\n\t\t\t\tcontext.link = false;\r\n\t\t\t}\r\n\t\t\tif (itemVar = tagCtx.props.itemVar) {\r\n\t\t\t\tif (itemVar.charAt(0) !== \"~\") {\r\n\t\t\t\t\tsyntaxError(\"Use itemVar='~myItem'\");\r\n\t\t\t\t}\r\n\t\t\t\titemVar = itemVar.slice(1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (view) {\r\n\t\t\tcontentTmpl = contentTmpl || view.content; // The wrapped content - to be added as #content property on views, below\r\n\t\t\tonRender = onRender || view._.onRender;\r\n\t\t\tcontext = context || view.ctx;\r\n\t\t}\r\n\r\n\t\tif (key === true) {\r\n\t\t\tswapContent = true;\r\n\t\t\tkey = 0;\r\n\t\t}\r\n\r\n\t\t// If link===false, do not call onRender, so no data-linking marker nodes\r\n\t\tif (onRender && (context && context.link === false || tag && tag._.noVws)) {\r\n\t\t\tonRender = undefined;\r\n\t\t}\r\n\t\touterOnRender = onRender;\r\n\t\tif (onRender === true) {\r\n\t\t\t// Used by view.refresh(). Don't create a new wrapper view.\r\n\t\t\touterOnRender = undefined;\r\n\t\t\tonRender = view._.onRender;\r\n\t\t}\r\n\t\t// Set additional context on views created here, (as modified context inherited from the parent, and to be inherited by child views)\r\n\t\tcontext = tmpl.helpers\r\n\t\t\t? extendCtx(tmpl.helpers, context)\r\n\t\t\t: context;\r\n\r\n\t\tnewCtx = context;\r\n\t\tif ($isArray(data) && !noIteration) {\r\n\t\t\t// Create a view for the array, whose child views correspond to each data item. (Note: if key and view are passed in\r\n\t\t\t// along with parent view, treat as insert -e.g. from view.addViews - so view is already the view item for array)\r\n\t\t\tnewView = swapContent\r\n\t\t\t\t? view\r\n\t\t\t\t: (key !== undefined && view)\r\n\t\t\t\t\t|| new View(context, \"array\", view, data, tmpl, key, contentTmpl, onRender);\r\n\t\t\tif (itemVar) {\r\n\t\t\t\tnewView.it = itemVar;\r\n\t\t\t}\r\n\t\t\titemVar = newView.it;\r\n\t\t\tfor (i = 0, l = data.length; i < l; i++) {\r\n\t\t\t\t// Create a view for each data item.\r\n\t\t\t\tif (itemVar) {\r\n\t\t\t\t\tsetItemVar(data[i]);  // use modified ctx with user-named ~item\r\n\t\t\t\t}\r\n\t\t\t\tchildView = new View(newCtx, \"item\", newView, data[i], tmpl, (key || 0) + i, contentTmpl, onRender);\r\n\r\n\t\t\t\titemResult = tmpl.fn(data[i], childView, $views);\r\n\t\t\t\tresult += newView._.onRender ? newView._.onRender(itemResult, childView) : itemResult;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// Create a view for singleton data object. The type of the view will be the tag name, e.g. \"if\" or \"myTag\" except for\r\n\t\t\t// \"item\", \"array\" and \"data\" views. A \"data\" view is from programmatic render(object) against a 'singleton'.\r\n\t\t\tif (itemVar) {\r\n\t\t\t\tsetItemVar(data);\r\n\t\t\t}\r\n\t\t\tnewView = swapContent ? view : new View(newCtx, tmplName || \"data\", view, data, tmpl, key, contentTmpl, onRender);\r\n\t\t\tif (tag && !tag.flow) {\r\n\t\t\t\tnewView.tag = tag;\r\n\t\t\t}\r\n\t\t\tresult += tmpl.fn(data, newView, $views);\r\n\t\t}\r\n\t\treturn outerOnRender ? outerOnRender(result, newView) : result;\r\n\t}\r\n\r\n\t//===========================\r\n\t// Build and compile template\r\n\t//===========================\r\n\r\n\t// Generate a reusable function that will serve to render a template against data\r\n\t// (Compile AST then build template function)\r\n\r\n\tfunction error(e, view, fallback) {\r\n\t\tvar message = $viewsSettings.onError(e, view, fallback);\r\n\t\tif (\"\" + e === e) { // if e is a string, not an Exception, then throw new Exception\r\n\t\t\tthrow new $sub.Err(message);\r\n\t\t}\r\n\t\treturn !view.linkCtx && view.linked ? $converters.html(message) : message;\r\n\t}\r\n\r\n\tfunction syntaxError(message) {\r\n\t\terror(\"Syntax error\\n\" + message);\r\n\t}\r\n\r\n\tfunction tmplFn(markup, tmpl, isLinkExpr, convertBack, hasElse) {\r\n\t\t// Compile markup to AST (abtract syntax tree) then build the template function code from the AST nodes\r\n\t\t// Used for compiling templates, and also by JsViews to build functions for data link expressions\r\n\r\n\t\t//==== nested functions ====\r\n\t\tfunction pushprecedingContent(shift) {\r\n\t\t\tshift -= loc;\r\n\t\t\tif (shift) {\r\n\t\t\t\tcontent.push(markup.substr(loc, shift).replace(rNewLine, \"\\\\n\"));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction blockTagCheck(tagName, block) {\r\n\t\t\tif (tagName) {\r\n\t\t\t\ttagName += '}}';\r\n\t\t\t\t//\t\t\t'{{include}} block has {{/for}} with no open {{for}}'\r\n\t\t\t\tsyntaxError((\r\n\t\t\t\t\tblock\r\n\t\t\t\t\t\t? '{{' + block + '}} block has {{/' + tagName + ' without {{' + tagName\r\n\t\t\t\t\t\t: 'Unmatched or missing {{/' + tagName) + ', in template:\\n' + markup);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction parseTag(all, bind, tagName, converter, colon, html, comment, codeTag, params, slash, closeBlock, index) {\r\n\r\n\t\t\t//    bind         tag        converter colon html     comment            code      params            slash   closeBlock\r\n\t\t\t// /{(\\^)?{(?:(?:(\\w+(?=[\\/\\s}]))|(?:(\\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\\*)))\\s*((?:[^}]|}(?!}))*?)(\\/)?|(?:\\/(\\w+)))}}/g\r\n\t\t\t// Build abstract syntax tree (AST): [tagName, converter, params, content, hash, bindings, contentMarkup]\r\n\t\t\tif (html) {\r\n\t\t\t\tcolon = \":\";\r\n\t\t\t\tconverter = HTML;\r\n\t\t\t}\r\n\t\t\tslash = slash || isLinkExpr && !hasElse;\r\n\r\n\t\t\tvar pathBindings = (bind || isLinkExpr) && [[]],\r\n\t\t\t\tprops = \"\",\r\n\t\t\t\targs = \"\",\r\n\t\t\t\tctxProps = \"\",\r\n\t\t\t\tparamsArgs = \"\",\r\n\t\t\t\tparamsProps = \"\",\r\n\t\t\t\tparamsCtxProps = \"\",\r\n\t\t\t\tonError = \"\",\r\n\t\t\t\tuseTrigger = \"\",\r\n\t\t\t\t// Block tag if not self-closing and not {{:}} or {{>}} (special case) and not a data-link expression\r\n\t\t\t\tblock = !slash && !colon && !comment;\r\n\r\n\t\t\t//==== nested helper function ====\r\n\t\t\ttagName = tagName || (params = params || \"#data\", colon); // {{:}} is equivalent to {{:#data}}\r\n\t\t\tpushprecedingContent(index);\r\n\t\t\tloc = index + all.length; // location marker - parsed up to here\r\n\t\t\tif (codeTag) {\r\n\t\t\t\tif (allowCode) {\r\n\t\t\t\t\tcontent.push([\"*\", \"\\n\" + params.replace(/^:/, \"ret+= \").replace(rUnescapeQuotes, \"$1\") + \";\\n\"]);\r\n\t\t\t\t}\r\n\t\t\t} else if (tagName) {\r\n\t\t\t\tif (tagName === \"else\") {\r\n\t\t\t\t\tif (rTestElseIf.test(params)) {\r\n\t\t\t\t\t\tsyntaxError('for \"{{else if expr}}\" use \"{{else expr}}\"');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpathBindings = current[7] && [[]];\r\n\t\t\t\t\tcurrent[8] = markup.substring(current[8], index); // contentMarkup for block tag\r\n\t\t\t\t\tcurrent = stack.pop();\r\n\t\t\t\t\tcontent = current[2];\r\n\t\t\t\t\tblock = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (params) {\r\n\t\t\t\t\t// remove newlines from the params string, to avoid compiled code errors for unterminated strings\r\n\t\t\t\t\tparseParams(params.replace(rNewLine, \" \"), pathBindings, tmpl)\r\n\t\t\t\t\t\t.replace(rBuildHash, function(all, onerror, isCtx, key, keyToken, keyValue, arg, param) {\r\n\t\t\t\t\t\t\tkey = \"'\" + keyToken + \"':\";\r\n\t\t\t\t\t\t\tif (arg) {\r\n\t\t\t\t\t\t\t\targs += keyValue + \",\";\r\n\t\t\t\t\t\t\t\tparamsArgs += \"'\" + param + \"',\";\r\n\t\t\t\t\t\t\t} else if (isCtx) {\r\n\t\t\t\t\t\t\t\tctxProps += key + keyValue + \",\";\r\n\t\t\t\t\t\t\t\tparamsCtxProps += key + \"'\" + param + \"',\";\r\n\t\t\t\t\t\t\t} else if (onerror) {\r\n\t\t\t\t\t\t\t\tonError += keyValue;\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tif (keyToken === \"trigger\") {\r\n\t\t\t\t\t\t\t\t\tuseTrigger += keyValue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tprops += key + keyValue + \",\";\r\n\t\t\t\t\t\t\t\tparamsProps += key + \"'\" + param + \"',\";\r\n\t\t\t\t\t\t\t\thasHandlers = hasHandlers || rHasHandlers.test(keyToken);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn \"\";\r\n\t\t\t\t\t\t}).slice(0, -1);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (pathBindings && pathBindings[0]) {\r\n\t\t\t\t\tpathBindings.pop(); // Remove the bindings that was prepared for next arg. (There is always an extra one ready).\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnewNode = [\r\n\t\t\t\t\t\ttagName,\r\n\t\t\t\t\t\tconverter || !!convertBack || hasHandlers || \"\",\r\n\t\t\t\t\t\tblock && [],\r\n\t\t\t\t\t\tparsedParam(paramsArgs, paramsProps, paramsCtxProps),\r\n\t\t\t\t\t\tparsedParam(args, props, ctxProps),\r\n\t\t\t\t\t\tonError,\r\n\t\t\t\t\t\tuseTrigger,\r\n\t\t\t\t\t\tpathBindings || 0\r\n\t\t\t\t\t];\r\n\t\t\t\tcontent.push(newNode);\r\n\t\t\t\tif (block) {\r\n\t\t\t\t\tstack.push(current);\r\n\t\t\t\t\tcurrent = newNode;\r\n\t\t\t\t\tcurrent[8] = loc; // Store current location of open tag, to be able to add contentMarkup when we reach closing tag\r\n\t\t\t\t}\r\n\t\t\t} else if (closeBlock) {\r\n\t\t\t\tblockTagCheck(closeBlock !== current[0] && current[0] !== \"else\" && closeBlock, current[0]);\r\n\t\t\t\tcurrent[8] = markup.substring(current[8], index); // contentMarkup for block tag\r\n\t\t\t\tcurrent = stack.pop();\r\n\t\t\t}\r\n\t\t\tblockTagCheck(!current && closeBlock);\r\n\t\t\tcontent = current[2];\r\n\t\t}\r\n\t\t//==== /end of nested functions ====\r\n\r\n\t\tvar result, newNode, hasHandlers,\r\n\t\t\tallowCode = $viewsSettings.allowCode || tmpl && tmpl.allowCode,\r\n\t\t\tastTop = [],\r\n\t\t\tloc = 0,\r\n\t\t\tstack = [],\r\n\t\t\tcontent = astTop,\r\n\t\t\tcurrent = [,,astTop];\r\n\r\n\t\tif (allowCode) {\r\n\t\t\ttmpl.allowCode = allowCode;\r\n\t\t}\r\n\r\n//TODO\tresult = tmplFnsCache[markup]; // Only cache if template is not named and markup length < ...,\r\n//and there are no bindings or subtemplates?? Consider standard optimization for data-link=\"a.b.c\"\r\n//\t\tif (result) {\r\n//\t\t\ttmpl.fn = result;\r\n//\t\t} else {\r\n\r\n//\t\tresult = markup;\r\n\t\tif (isLinkExpr) {\r\n\t\t\tmarkup = delimOpenChar0 + markup + delimCloseChar1;\r\n\t\t}\r\n\r\n\t\tblockTagCheck(stack[0] && stack[0][2].pop()[0]);\r\n\t\t// Build the AST (abstract syntax tree) under astTop\r\n\t\tmarkup.replace(rTag, parseTag);\r\n\r\n\t\tpushprecedingContent(markup.length);\r\n\r\n\t\tif (loc = astTop[astTop.length - 1]) {\r\n\t\t\tblockTagCheck(\"\" + loc !== loc && (+loc[8] === loc[8]) && loc[0]);\r\n\t\t}\r\n//\t\t\tresult = tmplFnsCache[markup] = buildCode(astTop, tmpl);\r\n//\t\t}\r\n\r\n\t\tif (isLinkExpr) {\r\n\t\t\tresult = buildCode(astTop, markup, isLinkExpr);\r\n\t\t\tsetPaths(result, [astTop[0][7]]); // With data-link expressions, pathBindings array is astTop[0][7]\r\n\t\t} else {\r\n\t\t\tresult = buildCode(astTop, tmpl);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction setPaths(fn, pathsArr) {\r\n\t\tvar key, paths,\r\n\t\t\ti = 0,\r\n\t\t\tl = pathsArr.length;\r\n\t\tfn.deps = [];\r\n\t\tfor (; i < l; i++) {\r\n\t\t\tpaths = pathsArr[i];\r\n\t\t\tfor (key in paths) {\r\n\t\t\t\tif (key !== \"_jsvto\" && paths[key].length) {\r\n\t\t\t\t\tfn.deps = fn.deps.concat(paths[key]); // deps is the concatenation of the paths arrays for the different bindings\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfn.paths = paths; // The array of paths arrays for the different bindings\r\n}\r\n\r\n\tfunction parsedParam(args, props, ctx) {\r\n\t\treturn [args.slice(0, -1), props.slice(0, -1), ctx.slice(0, -1)];\r\n\t}\r\n\r\n\tfunction paramStructure(parts, type) {\r\n\t\treturn '\\n\\t'\r\n\t\t\t+ (type\r\n\t\t\t\t? type + ':{'\r\n\t\t\t\t: '')\r\n\t\t\t+ 'args:[' + parts[0] + ']'\r\n\t\t\t+ (parts[1] || !type\r\n\t\t\t\t? ',\\n\\tprops:{' + parts[1] + '}'\r\n\t\t\t\t: \"\")\r\n\t\t\t+ (parts[2] ? ',\\n\\tctx:{' + parts[2] + '}' : \"\");\r\n\t}\r\n\r\n\tfunction parseParams(params, pathBindings, tmpl) {\r\n\r\n\t\tfunction parseTokens(all, lftPrn0, lftPrn, bound, path, operator, err, eq, path2, prn, comma, lftPrn2, apos, quot, rtPrn, rtPrnDot, prn2, space, index, full) {\r\n\t\t// /(\\()(?=\\s*\\()|(?:([([])\\s*)?(?:(\\^?)(!*?[#~]?[\\w$.^]+)?\\s*((\\+\\+|--)|\\+|-|&&|\\|\\||===|!==|==|!=|<=|>=|[<>%*:?\\/]|(=))\\s*|(!*?[#~]?[\\w$.^]+)([([])?)|(,\\s*)|(\\(?)\\\\?(?:(')|(\"))|(?:\\s*(([)\\]])(?=\\s*[.^]|\\s*$|\\s)|[)\\]])([([]?))|(\\s+)/g,\r\n\t\t//   lftPrn0        lftPrn        bound            path    operator err                                                eq             path2       prn    comma   lftPrn2   apos quot      rtPrn rtPrnDot                    prn2  space\r\n\t\t\t// (left paren? followed by (path? followed by operator) or (path followed by paren?)) or comma or apos or quot or right paren or space\r\n\t\t\tbound = bindings && bound;\r\n\t\t\tif (bound && !eq) {\r\n\t\t\t\tpath = bound + path; // e.g. some.fn(...)^some.path - so here path is \"^some.path\"\r\n\t\t\t}\r\n\t\t\toperator = operator || \"\";\r\n\t\t\tlftPrn = lftPrn || lftPrn0 || lftPrn2;\r\n\t\t\tpath = path || path2;\r\n\t\t\t// Could do this - but not worth perf cost?? :-\r\n\t\t\t// if (!path.lastIndexOf(\"#data.\", 0)) { path = path.slice(6); } // If path starts with \"#data.\", remove that.\r\n\t\t\tprn = prn || prn2 || \"\";\r\n\r\n\t\t\tvar expr, exprFn, binds, theOb, newOb;\r\n\r\n\t\t\tfunction parsePath(allPath, not, object, helper, view, viewProperty, pathTokens, leafToken) {\r\n\t\t\t\t// rPath = /^(?:null|true|false|\\d[\\d.]*|(!*?)([\\w$]+|\\.|~([\\w$]+)|#(view|([\\w$]+))?)([\\w$.^]*?)(?:[.[^]([\\w$]+)\\]?)?)$/g,\r\n\t\t\t\t//                                        none   object     helper    view  viewProperty pathTokens      leafToken\r\n\t\t\t\tvar subPath = object === \".\";\r\n\t\t\t\tif (object) {\r\n\t\t\t\t\tpath = path.slice(not.length);\r\n\t\t\t\t\tif (!subPath) {\r\n\t\t\t\t\t\tallPath = (helper\r\n\t\t\t\t\t\t\t\t? 'view.hlp(\"' + helper + '\")'\r\n\t\t\t\t\t\t\t\t: view\r\n\t\t\t\t\t\t\t\t\t? \"view\"\r\n\t\t\t\t\t\t\t\t\t: \"data\")\r\n\t\t\t\t\t\t\t+ (leafToken\r\n\t\t\t\t\t\t\t\t? (viewProperty\r\n\t\t\t\t\t\t\t\t\t? \".\" + viewProperty\r\n\t\t\t\t\t\t\t\t\t: helper\r\n\t\t\t\t\t\t\t\t\t\t? \"\"\r\n\t\t\t\t\t\t\t\t\t\t: (view ? \"\" : \".\" + object)\r\n\t\t\t\t\t\t\t\t\t) + (pathTokens || \"\")\r\n\t\t\t\t\t\t\t\t: (leafToken = helper ? \"\" : view ? viewProperty || \"\" : object, \"\"));\r\n\r\n\t\t\t\t\t\tallPath = allPath + (leafToken ? \".\" + leafToken : \"\");\r\n\r\n\t\t\t\t\t\tallPath = not + (allPath.slice(0, 9) === \"view.data\"\r\n\t\t\t\t\t\t\t? allPath.slice(5) // convert #view.data... to data...\r\n\t\t\t\t\t\t\t: allPath);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (bindings) {\r\n\t\t\t\t\t\tbinds = named === \"linkTo\" ? (bindto = pathBindings._jsvto = pathBindings._jsvto || []) : bndCtx.bd;\r\n\t\t\t\t\t\tif (theOb = subPath && binds[binds.length-1]) {\r\n\t\t\t\t\t\t\tif (theOb._jsv) {\r\n\t\t\t\t\t\t\t\twhile (theOb.sb) {\r\n\t\t\t\t\t\t\t\t\ttheOb = theOb.sb;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (theOb.bnd) {\r\n\t\t\t\t\t\t\t\t\tpath = \"^\" + path.slice(1);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\ttheOb.sb = path;\r\n\t\t\t\t\t\t\t\ttheOb.bnd = theOb.bnd || path.charAt(0) === \"^\";\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tbinds.push(path);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpathStart[parenDepth] = index + (subPath ? 1 : 0);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn allPath;\r\n\t\t\t}\r\n\r\n\t\t\tif (err && !aposed && !quoted) {\r\n\t\t\t\tsyntaxError(params);\r\n\t\t\t} else {\r\n\t\t\t\tif (bindings && rtPrnDot && !aposed && !quoted) {\r\n\t\t\t\t\t// This is a binding to a path in which an object is returned by a helper/data function/expression, e.g. foo()^x.y or (a?b:c)^x.y\r\n\t\t\t\t\t// We create a compiled function to get the object instance (which will be called when the dependent data of the subexpression changes, to return the new object, and trigger re-binding of the subsequent path)\r\n\t\t\t\t\tif (!named || boundName || bindto) {\r\n\t\t\t\t\t\texpr = pathStart[parenDepth - 1];\r\n\t\t\t\t\t\tif (full.length - 1 > index - (expr || 0)) { // We need to compile a subexpression\r\n\t\t\t\t\t\t\texpr = full.slice(expr, index + all.length);\r\n\t\t\t\t\t\t\tif (exprFn !== true) { // If not reentrant call during compilation\r\n\t\t\t\t\t\t\t\tbinds = bindto || bndStack[parenDepth-1].bd;\r\n\t\t\t\t\t\t\t\t// Insert exprOb object, to be used during binding to return the computed object\r\n\t\t\t\t\t\t\t\ttheOb = binds[binds.length-1];\r\n\t\t\t\t\t\t\t\tif (theOb && theOb.prm) {\r\n\t\t\t\t\t\t\t\t\twhile (theOb.sb && theOb.sb.prm) {\r\n\t\t\t\t\t\t\t\t\t\ttheOb = theOb.sb;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tnewOb = theOb.sb = {path: theOb.sb, bnd: theOb.bnd};\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tbinds.push(newOb = {path: binds.pop()}); // Insert exprOb object, to be used during binding to return the computed object\r\n\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t // (e.g. \"some.object()\" in \"some.object().a.b\" - to be used as context for binding the following tokens \"a.b\")\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\trtPrnDot = delimOpenChar1 + \":\" + expr // The parameter or function subexpression\r\n\t\t\t\t\t\t\t\t+ \" onerror=''\" // set onerror='' in order to wrap generated code with a try catch - returning '' as object instance if there is an error/missing parent\r\n\t\t\t\t\t\t\t\t+ delimCloseChar0;\r\n\t\t\t\t\t\t\texprFn = tmplLinks[rtPrnDot];\r\n\t\t\t\t\t\t\tif (!exprFn) {\r\n\t\t\t\t\t\t\t\ttmplLinks[rtPrnDot] = true; // Flag that this exprFn (for rtPrnDot) is being compiled\r\n\t\t\t\t\t\t\t\ttmplLinks[rtPrnDot] = exprFn = tmplFn(rtPrnDot, tmpl, true); // Compile the expression (or use cached copy already in tmpl.links)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (exprFn !== true && newOb) {\r\n\t\t\t\t\t\t\t\t// If not reentrant call during compilation\r\n\t\t\t\t\t\t\t\tnewOb._jsv = exprFn;\r\n\t\t\t\t\t\t\t\tnewOb.prm = bndCtx.bd;\r\n\t\t\t\t\t\t\t\tnewOb.bnd = newOb.bnd || newOb.path && newOb.path.indexOf(\"^\") >= 0;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn (aposed\r\n\t\t\t\t\t// within single-quoted string\r\n\t\t\t\t\t? (aposed = !apos, (aposed ? all : lftPrn2 + '\"'))\r\n\t\t\t\t\t: quoted\r\n\t\t\t\t\t// within double-quoted string\r\n\t\t\t\t\t\t? (quoted = !quot, (quoted ? all : lftPrn2 + '\"'))\r\n\t\t\t\t\t\t:\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t(lftPrn\r\n\t\t\t\t\t\t\t? (pathStart[parenDepth] = index++, bndCtx = bndStack[++parenDepth] = {bd: []}, lftPrn)\r\n\t\t\t\t\t\t\t: \"\")\r\n\t\t\t\t\t\t+ (space\r\n\t\t\t\t\t\t\t? (parenDepth\r\n\t\t\t\t\t\t\t\t? \"\"\r\n\t\t\t\t\t// New arg or prop - so insert backspace \\b (\\x08) as separator for named params, used subsequently by rBuildHash, and prepare new bindings array\r\n\t\t\t\t\t\t\t\t: (paramIndex = full.slice(paramIndex, index), named\r\n\t\t\t\t\t\t\t\t\t? (named = boundName = bindto = false, \"\\b\")\r\n\t\t\t\t\t\t\t\t\t: \"\\b,\") + paramIndex + (paramIndex = index + all.length, bindings && pathBindings.push(bndCtx.bd = []), \"\\b\")\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t: eq\r\n\t\t\t\t\t// named param. Remove bindings for arg and create instead bindings array for prop\r\n\t\t\t\t\t\t\t\t? (parenDepth && syntaxError(params), bindings && pathBindings.pop(), named = path, boundName = bound, paramIndex = index + all.length, bound && (bindings = bndCtx.bd = pathBindings[named] = []), path + ':')\r\n\t\t\t\t\t\t\t\t: path\r\n\t\t\t\t\t// path\r\n\t\t\t\t\t\t\t\t\t? (path.split(\"^\").join(\".\").replace(rPath, parsePath)\r\n\t\t\t\t\t\t\t\t\t\t+ (prn\r\n\t\t\t\t\t// some.fncall(\r\n\t\t\t\t\t\t\t\t\t\t\t? (bndCtx = bndStack[++parenDepth] = {bd: []}, fnCall[parenDepth] = true, prn)\r\n\t\t\t\t\t\t\t\t\t\t\t: operator)\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t: operator\r\n\t\t\t\t\t// operator\r\n\t\t\t\t\t\t\t\t\t\t? operator\r\n\t\t\t\t\t\t\t\t\t\t: rtPrn\r\n\t\t\t\t\t// function\r\n\t\t\t\t\t\t\t\t\t\t\t? ((fnCall[parenDepth] = false, bndCtx = bndStack[--parenDepth], rtPrn)\r\n\t\t\t\t\t\t\t\t\t\t\t\t+ (prn // rtPrn and prn, e.g )( in (a)() or a()(), or )[ in a()[]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t? (bndCtx = bndStack[++parenDepth], fnCall[parenDepth] = true, prn)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t: \"\")\r\n\t\t\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t\t\t\t: comma\r\n\t\t\t\t\t\t\t\t\t\t\t\t? (fnCall[parenDepth] || syntaxError(params), \",\") // We don't allow top-level literal arrays or objects\r\n\t\t\t\t\t\t\t\t\t\t\t\t: lftPrn0\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t? \"\"\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t: (aposed = apos, quoted = quot, '\"')\r\n\t\t\t\t\t))\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tvar named, bindto, boundName,\r\n\t\t\tquoted, // boolean for string content in double quotes\r\n\t\t\taposed, // or in single quotes\r\n\t\t\tbindings = pathBindings && pathBindings[0], // bindings array for the first arg\r\n\t\t\tbndCtx = {bd: bindings},\r\n\t\t\tbndStack = {0: bndCtx},\r\n\t\t\tparamIndex = 0, // list,\r\n\t\t\ttmplLinks = tmpl ? tmpl.links : bindings && (bindings.links = bindings.links || {}),\r\n\t\t\t// The following are used for tracking path parsing including nested paths, such as \"a.b(c^d + (e))^f\", and chained computed paths such as\r\n\t\t\t// \"a.b().c^d().e.f().g\" - which has four chained paths, \"a.b()\", \"^c.d()\", \".e.f()\" and \".g\"\r\n\t\t\tparenDepth = 0,\r\n\t\t\tfnCall = {}, // We are in a function call\r\n\t\t\tpathStart = {}; // tracks the start of the current path such as c^d() in the above example\r\n\r\n\t\treturn (params + (tmpl ? \" \" : \"\"))\r\n\t\t\t.replace(rParams, parseTokens);\r\n\t}\r\n\r\n\tfunction buildCode(ast, tmpl, isLinkExpr) {\r\n\t\t// Build the template function code from the AST nodes, and set as property on the passed-in template object\r\n\t\t// Used for compiling templates, and also by JsViews to build functions for data link expressions\r\n\t\tvar i, node, tagName, converter, tagCtx, hasTag, hasEncoder, getsVal, hasCnvt, useCnvt, tmplBindings, pathBindings, params, boundOnErrStart, boundOnErrEnd,\r\n\t\t\ttagRender, nestedTmpls, tmplName, nestedTmpl, tagAndElses, content, markup, nextIsElse, oldCode, isElse, isGetVal, tagCtxFn, onError, tagStart, trigger,\r\n\t\t\ttmplBindingKey = 0,\r\n\t\t\tuseViews = tmpl.useViews || tmpl.tags || tmpl.templates || tmpl.helpers || tmpl.converters,\r\n\t\t\tcode = \"\",\r\n\t\t\ttmplOptions = {},\r\n\t\t\tl = ast.length;\r\n\r\n\t\tif (\"\" + tmpl === tmpl) {\r\n\t\t\ttmplName = isLinkExpr ? 'data-link=\"' + tmpl.replace(rNewLine, \" \").slice(1, -1) + '\"' : tmpl;\r\n\t\t\ttmpl = 0;\r\n\t\t} else {\r\n\t\t\ttmplName = tmpl.tmplName || \"unnamed\";\r\n\t\t\tif (tmpl.allowCode) {\r\n\t\t\t\ttmplOptions.allowCode = true;\r\n\t\t\t}\r\n\t\t\tif (tmpl.debug) {\r\n\t\t\t\ttmplOptions.debug = true;\r\n\t\t\t}\r\n\t\t\ttmplBindings = tmpl.bnds;\r\n\t\t\tnestedTmpls = tmpl.tmpls;\r\n\t\t}\r\n\t\tfor (i = 0; i < l; i++) {\r\n\t\t\t// AST nodes: [0: tagName, 1: converter, 2: content, 3: params, 4: code, 5: onError, 6: trigger, 7:pathBindings, 8: contentMarkup]\r\n\t\t\tnode = ast[i];\r\n\r\n\t\t\t// Add newline for each callout to t() c() etc. and each markup string\r\n\t\t\tif (\"\" + node === node) {\r\n\t\t\t\t// a markup string to be inserted\r\n\t\t\t\tcode += '\\n+\"' + node + '\"';\r\n\t\t\t} else {\r\n\t\t\t\t// a compiled tag expression to be inserted\r\n\t\t\t\ttagName = node[0];\r\n\t\t\t\tif (tagName === \"*\") {\r\n\t\t\t\t\t// Code tag: {{* }}\r\n\t\t\t\t\tcode += \";\\n\" + node[1] + \"\\nret=ret\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconverter = node[1];\r\n\t\t\t\t\tcontent = !isLinkExpr && node[2];\r\n\t\t\t\t\ttagCtx = paramStructure(node[3], 'params') + '},' + paramStructure(params = node[4]);\r\n\t\t\t\t\tonError = node[5];\r\n\t\t\t\t\ttrigger = node[6];\r\n\t\t\t\t\tmarkup = node[8] && node[8].replace(rUnescapeQuotes, \"$1\");\r\n\t\t\t\t\tif (isElse = tagName === \"else\") {\r\n\t\t\t\t\t\tif (pathBindings) {\r\n\t\t\t\t\t\t\tpathBindings.push(node[7]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttmplBindingKey = 0;\r\n\t\t\t\t\t\tif (tmplBindings && (pathBindings = node[7])) { // Array of paths, or false if not data-bound\r\n\t\t\t\t\t\t\tpathBindings = [pathBindings];\r\n\t\t\t\t\t\t\ttmplBindingKey = tmplBindings.push(1); // Add placeholder in tmplBindings for compiled function\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tuseViews = useViews || params[1] || params[2] || pathBindings || /view.(?!index)/.test(params[0]);\r\n\t\t\t\t\t// useViews is for perf optimization. For render() we only use views if necessary - for the more advanced scenarios.\r\n\t\t\t\t\t// We use views if there are props, contextual properties or args with #... (other than #index) - but you can force\r\n\t\t\t\t\t// using the full view infrastructure, (and pay a perf price) by opting in: Set useViews: true on the template, manually...\r\n\t\t\t\t\tif (isGetVal = tagName === \":\") {\r\n\t\t\t\t\t\tif (converter) {\r\n\t\t\t\t\t\t\ttagName = converter === HTML ? \">\" : converter + tagName;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (content) { // TODO optimize - if content.length === 0 or if there is a tmpl=\"...\" specified - set content to null / don't run this compilation code - since content won't get used!!\r\n\t\t\t\t\t\t\t// Create template object for nested template\r\n\t\t\t\t\t\t\tnestedTmpl = tmplObject(markup, tmplOptions);\r\n\t\t\t\t\t\t\tnestedTmpl.tmplName = tmplName + \"/\" + tagName;\r\n\t\t\t\t\t\t\t// Compile to AST and then to compiled function\r\n\t\t\t\t\t\t\tnestedTmpl.useViews = nestedTmpl.useViews || useViews;\r\n\t\t\t\t\t\t\tbuildCode(content, nestedTmpl);\r\n\t\t\t\t\t\t\tuseViews = nestedTmpl.useViews;\r\n\t\t\t\t\t\t\tnestedTmpls.push(nestedTmpl);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!isElse) {\r\n\t\t\t\t\t\t\t// This is not an else tag.\r\n\t\t\t\t\t\t\ttagAndElses = tagName;\r\n\t\t\t\t\t\t\tuseViews = useViews || tagName && (!$tags[tagName] || !$tags[tagName].flow);\r\n\t\t\t\t\t\t\t// Switch to a new code string for this bound tag (and its elses, if it has any) - for returning the tagCtxs array\r\n\t\t\t\t\t\t\toldCode = code;\r\n\t\t\t\t\t\t\tcode = \"\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tnextIsElse = ast[i + 1];\r\n\t\t\t\t\t\tnextIsElse = nextIsElse && nextIsElse[0] === \"else\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttagStart = onError ? \";\\ntry{\\nret+=\" : \"\\n+\";\r\n\t\t\t\t\tboundOnErrStart = \"\";\r\n\t\t\t\t\tboundOnErrEnd = \"\";\r\n\r\n\t\t\t\t\tif (isGetVal && (pathBindings || trigger || converter && converter !== HTML)) {\r\n\t\t\t\t\t\t// For convertVal we need a compiled function to return the new tagCtx(s)\r\n\t\t\t\t\t\ttagCtxFn = \"return {\" + tagCtx + \"};\";\r\n\t\t\t\t\t\ttagRender = 'c(\"' + converter + '\",view,';\r\n\t\t\t\t\t\ttagCtxFn = new Function(\"data,view,j,u\", \" // \" + tmplName + \" \" + tmplBindingKey + \" \" + tagName\r\n\t\t\t\t\t\t\t\t\t\t\t+ \"\\n\" + tagCtxFn);\r\n\t\t\t\t\t\ttagCtxFn._er = onError;\r\n\r\n\t\t\t\t\t\tboundOnErrStart = tagRender + tmplBindingKey + \",\";\r\n\t\t\t\t\t\tboundOnErrEnd = \")\";\r\n\r\n\t\t\t\t\t\ttagCtxFn._tag = tagName;\r\n\t\t\t\t\t\tif (isLinkExpr) {\r\n\t\t\t\t\t\t\treturn tagCtxFn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsetPaths(tagCtxFn, pathBindings);\r\n\t\t\t\t\t\tuseCnvt = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcode += (isGetVal\r\n\t\t\t\t\t\t? (isLinkExpr ? (onError ? \"\\ntry{\\n\" : \"\") + \"return \" : tagStart) + (useCnvt // Call _cnvt if there is a converter: {{cnvt: ... }} or {^{cnvt: ... }}\r\n\t\t\t\t\t\t\t? (useCnvt = undefined, useViews = hasCnvt = true, tagRender + (pathBindings\r\n\t\t\t\t\t\t\t\t? ((tmplBindings[tmplBindingKey - 1] = tagCtxFn), tmplBindingKey) // Store the compiled tagCtxFn in tmpl.bnds, and pass the key to convertVal()\r\n\t\t\t\t\t\t\t\t: \"{\" + tagCtx + \"}\") + \")\")\r\n\t\t\t\t\t\t\t: tagName === \">\"\r\n\t\t\t\t\t\t\t\t? (hasEncoder = true, \"h(\" + params[0] + ')')\r\n\t\t\t\t\t\t\t\t: (getsVal = true, \"((v=\" + (params[0] || 'data') + ')!=null?v:\"\")') // Strict equality just for data-link=\"title{:expr}\" so expr=null will remove title attribute\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t: (hasTag = true, \"\\n{view:view,tmpl:\" // Add this tagCtx to the compiled code for the tagCtxs to be passed to renderTag()\r\n\t\t\t\t\t\t\t+ (content ? nestedTmpls.length : \"0\") + \",\" // For block tags, pass in the key (nestedTmpls.length) to the nested content template\r\n\t\t\t\t\t\t\t+ tagCtx + \"},\"));\r\n\r\n\t\t\t\t\tif (tagAndElses && !nextIsElse) {\r\n\t\t\t\t\t\t// This is a data-link expression or an inline tag without any elses, or the last {{else}} of an inline tag\r\n\t\t\t\t\t\t// We complete the code for returning the tagCtxs array\r\n\t\t\t\t\t\tcode = \"[\" + code.slice(0, -1) + \"]\";\r\n\t\t\t\t\t\ttagRender = 't(\"' + tagAndElses + '\",view,this,';\r\n\t\t\t\t\t\tif (isLinkExpr || pathBindings) {\r\n\t\t\t\t\t\t\t// This is a bound tag (data-link expression or inline bound tag {^{tag ...}}) so we store a compiled tagCtxs function in tmp.bnds\r\n\t\t\t\t\t\t\tcode = new Function(\"data,view,j,u\", \" // \" + tmplName + \" \" + tmplBindingKey + \" \" + tagAndElses + \"\\nreturn \" + code + \";\");\r\n\t\t\t\t\t\t\tcode._er = onError;\r\n\t\t\t\t\t\t\tcode._tag = tagAndElses;\r\n\t\t\t\t\t\t\tif (pathBindings) {\r\n\t\t\t\t\t\t\t\tsetPaths(tmplBindings[tmplBindingKey - 1] = code, pathBindings);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (isLinkExpr) {\r\n\t\t\t\t\t\t\t\treturn code; // For a data-link expression we return the compiled tagCtxs function\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tboundOnErrStart = tagRender + tmplBindingKey + \",undefined,\";\r\n\t\t\t\t\t\t\tboundOnErrEnd = \")\";\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// This is the last {{else}} for an inline tag.\r\n\t\t\t\t\t\t// For a bound tag, pass the tagCtxs fn lookup key to renderTag.\r\n\t\t\t\t\t\t// For an unbound tag, include the code directly for evaluating tagCtxs array\r\n\t\t\t\t\t\tcode = oldCode + tagStart + tagRender + (tmplBindingKey || code) + \")\";\r\n\t\t\t\t\t\tpathBindings = 0;\r\n\t\t\t\t\t\ttagAndElses = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (onError) {\r\n\t\t\t\t\t\tuseViews = true;\r\n\t\t\t\t\t\tcode += ';\\n}catch(e){ret' + (isLinkExpr ? \"urn \" : \"+=\") + boundOnErrStart + 'j._err(e,view,' + onError + ')' + boundOnErrEnd + ';}\\n' + (isLinkExpr ? \"\" : 'ret=ret');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Include only the var references that are needed in the code\r\n\t\tcode = \"// \" + tmplName\r\n\r\n\t\t\t+ \"\\nvar v\"\r\n\t\t\t+ (hasTag ? \",t=j._tag\" : \"\")                // has tag\r\n\t\t\t+ (hasCnvt ? \",c=j._cnvt\" : \"\")              // converter\r\n\t\t\t+ (hasEncoder ? \",h=j.converters.html\" : \"\") // html converter\r\n\t\t\t+ (isLinkExpr ? \";\\n\" : ',ret=\"\"\\n')\r\n\t\t\t+ (tmplOptions.debug ? \"debugger;\" : \"\")\r\n\t\t\t+ code\r\n\t\t\t+ (isLinkExpr ? \"\\n\" : \";\\nreturn ret;\");\r\n\r\n\t\tif ($viewsSettings._dbgMode) {\r\n\t\t\tcode = \"try {\\n\" + code + \"\\n}catch(e){\\nreturn j._err(e, view);\\n}\";\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tcode = new Function(\"data,view,j,u\", code);\r\n\t\t} catch (e) {\r\n\t\t\tsyntaxError(\"Compiled template code:\\n\\n\" + code + '\\n: \"' + e.message + '\"');\r\n\t\t}\r\n\t\tif (tmpl) {\r\n\t\t\ttmpl.fn = code;\r\n\t\t\ttmpl.useViews = !!useViews;\r\n\t\t}\r\n\t\treturn code;\r\n\t}\r\n\r\n\t//==========\r\n\t// Utilities\r\n\t//==========\r\n\r\n\t// Merge objects, in particular contexts which inherit from parent contexts\r\n\tfunction extendCtx(context, parentContext) {\r\n\t\t// Return copy of parentContext, unless context is defined and is different, in which case return a new merged context\r\n\t\t// If neither context nor parentContext are defined, return undefined\r\n\t\treturn context && context !== parentContext\r\n\t\t\t? (parentContext\r\n\t\t\t\t? $extend($extend({}, parentContext), context)\r\n\t\t\t\t: context)\r\n\t\t\t: parentContext && $extend({}, parentContext);\r\n\t}\r\n\r\n\t// Get character entity for HTML and Attribute encoding\r\n\tfunction getCharEntity(ch) {\r\n\t\treturn charEntities[ch] || (charEntities[ch] = \"&#\" + ch.charCodeAt(0) + \";\");\r\n\t}\r\n\r\n\t//========================== Initialize ==========================\r\n\r\n\tfor (jsvStoreName in jsvStores) {\r\n\t\tregisterStore(jsvStoreName, jsvStores[jsvStoreName]);\r\n\t}\r\n\r\n\tvar $isFunction, $isArray,\r\n\t\t$templates = $views.templates,\r\n\t\t$converters = $views.converters,\r\n\t\t$helpers = $views.helpers,\r\n\t\t$tags = $views.tags,\r\n\t\t$sub = $views.sub,\r\n\t\t$viewsSettings = $views.settings;\r\n\r\n\t$sub._tg.prototype = {\r\n\t\tbaseApply: baseApply,\r\n\t\tcvtArgs: convertArgs\r\n\t};\r\n\r\n\ttopView = $sub.topView = new View();\r\n\r\n\t//BROWSER-SPECIFIC CODE\r\n\tif ($) {\r\n\t\t////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\t// jQuery (= $) is loaded\r\n\r\n\t\t$.fn.render = function(data, context, noIteration) {\r\n\t\t\tvar tmplElem = this.jquery && (this[0] || error('Unknown template: \"' + this.selector + '\"')),\r\n\t\t\t\ttmpl = tmplElem.getAttribute(tmplAttr);\r\n\r\n\t\t\treturn renderContent.call(tmpl ? $.data(tmplElem)[jsvTmpl] : $templates(tmplElem), data, context, noIteration);\r\n\t\t};\r\n\r\n\t\tif ($.observable) {\r\n\t\t\t$extend($sub, $.views.sub); // jquery.observable.js was loaded before jsrender.js\r\n\t\t\t$views.map = $.views.map;\r\n\t\t}\r\n\t} else {\r\n\t\t////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\t// jQuery is not loaded.\r\n\r\n\t\t$ = {};\r\n\r\n\t\tif (!isAmd) {\r\n\t\t\t// We are loading jsrender.js from a script element, not AMD, so set global\r\n\t\t\tglobal.jsrender = $;\r\n\t\t}\r\n\r\n\t\t// Error warning if jsrender.js is used on as template engine on Node.js (e.g. Express or Hapi...)\r\n\t\t// Use jsrender-node.js instead...\r\n\t\t$.renderFile = $.__express = function() { throw \"Node.js: use jsviews.com/download/jsrender-node.js\"; };\r\n\r\n\t\t//END BROWSER-SPECIFIC CODE\r\n\t\t$.isFunction = function(ob) {\r\n\t\t\treturn typeof ob === \"function\";\r\n\t\t};\r\n\r\n\t\t$.isArray = Array.isArray || function(obj) {\r\n\t\t\treturn $.toString.call(obj) === \"[object Array]\";\r\n\t\t};\r\n\r\n\t\t$.noConflict = function() {\r\n\t\t\tif (global.jsrender === $) {\r\n\t\t\t\tglobal.jsrender = jsrenderPrev;\r\n\t\t\t}\r\n\t\t\treturn $;\r\n\t\t};\r\n\t}\r\n\r\n\t$isFunction = $.isFunction;\r\n\t$isArray = $.isArray;\r\n\t$.render = $render;\r\n\t$.views = $views;\r\n\t$.templates = $templates = $views.templates;\r\n\r\n\t$views.compile = function(markup, options) {\r\n\t\toptions = options || {};\r\n\t\toptions.markup = markup;\r\n\t\treturn $templates(options);\r\n\t};\r\n\r\n\t$viewsSettings({\r\n\t\tdebugMode: dbgMode,\r\n\t\tdelimiters: $viewsDelimiters,\r\n\t\tonError: function(e, view, fallback) {\r\n\t\t\t// Can override using $.views.settings({onError: function(...) {...}});\r\n\t\t\tif (view) {\r\n\t\t\t\t// For render errors, e is an exception thrown in compiled template, and view is the current view. For other errors, e is an error string.\r\n\t\t\t\te = fallback === undefined\r\n\t\t\t\t\t? \"{Error: \" + (e.message || e) + \"}\"\r\n\t\t\t\t\t: $isFunction(fallback)\r\n\t\t\t\t\t\t? fallback(e, view) : fallback;\r\n\t\t\t}\r\n\t\t\treturn e == undefined ? \"\" : e;\r\n\t\t},\r\n\t\t_dbgMode: false\r\n\t});\r\n\r\n\t//========================== Register tags ==========================\r\n\r\n\t$tags({\r\n\t\t\"if\": {\r\n\t\t\trender: function(val) {\r\n\t\t\t\t// This function is called once for {{if}} and once for each {{else}}.\r\n\t\t\t\t// We will use the tag.rendering object for carrying rendering state across the calls.\r\n\t\t\t\t// If not done (a previous block has not been rendered), look at expression for this block and render the block if expression is truthy\r\n\t\t\t\t// Otherwise return \"\"\r\n\t\t\t\tvar self = this,\r\n\t\t\t\t\ttagCtx = self.tagCtx,\r\n\t\t\t\t\tret = (self.rendering.done || !val && (arguments.length || !tagCtx.index))\r\n\t\t\t\t\t\t? \"\"\r\n\t\t\t\t\t\t: (self.rendering.done = true, self.selected = tagCtx.index,\r\n\t\t\t\t\t\t\t// Test is satisfied, so render content on current context. We call tagCtx.render() rather than return undefined\r\n\t\t\t\t\t\t\t// (which would also render the tmpl/content on the current context but would iterate if it is an array)\r\n\t\t\t\t\t\t\ttagCtx.render(tagCtx.view, true)); // no arg, so renders against parentView.data\r\n\t\t\t\treturn ret;\r\n\t\t\t},\r\n\t\t\tflow: true\r\n\t\t},\r\n\t\t\"for\": {\r\n\t\t\trender: function (val) {\r\n\t\t\t\t// This function is called once for {{for}} and once for each {{else}}.\r\n\t\t\t\t// We will use the tag.rendering object for carrying rendering state across the calls.\r\n\t\t\t\tvar finalElse = !arguments.length,\r\n\t\t\t\t\tvalue,\r\n\t\t\t\t\tself = this,\r\n\t\t\t\t\ttagCtx = self.tagCtx,\r\n\t\t\t\t\tresult = \"\",\r\n\t\t\t\t\tdone = 0;\r\n\r\n\t\t\t\tif (!self.rendering.done) {\r\n\t\t\t\t\tvalue = finalElse ? tagCtx.view.data : val; // For the final else, defaults to current data without iteration.\r\n\t\t\t\t\tif (value !== undefined ) {\r\n\t\t\t\t\t\tresult += tagCtx.render(value, finalElse); // Iterates except on final else, if data is an array. (Use {{include}} to compose templates without array iteration)\r\n\t\t\t\t\t\tdone += $isArray(value) ? value.length : 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (self.rendering.done = done) {\r\n\t\t\t\t\t\tself.selected = tagCtx.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// If nothing was rendered we will look at the next {{else}}. Otherwise, we are done.\r\n\t\t\t\t}\r\n\t\t\t\treturn result;\r\n\t\t\t},\r\n\t\t\tflow: true\r\n\t\t},\r\n\t\tprops: {\r\n\t\t\tbaseTag: \"for\",\r\n\t\t\tdataMap: dataMap(getTargetProps),\r\n\t\t\tflow: true\r\n\t\t},\r\n\t\tinclude: {\r\n\t\t\tflow: true\r\n\t\t},\r\n\t\t\"*\": {\r\n\t\t\t// {{* code... }} - Ignored if template.allowCode and $.views.settings.allowCode are false. Otherwise include code in compiled template\r\n\t\t\trender: retVal,\r\n\t\t\tflow: true\r\n\t\t},\r\n\t\t\":*\": {\r\n\t\t\t// {{:* returnedExpression }} - Ignored if template.allowCode and $.views.settings.allowCode are false. Otherwise include code in compiled template\r\n\t\t\trender: retVal,\r\n\t\t\tflow: true\r\n\t\t},\r\n\t\tdbg: $helpers.dbg = $converters.dbg = dbgBreak // Register {{dbg/}}, {{dbg:...}} and ~dbg() to throw and catch, as breakpoints for debugging.\r\n\t});\r\n\r\n\tfunction getTargetProps(source) {\r\n\t\t// this pointer is theMap - which has tagCtx.props too\r\n\t\t// arguments: tagCtx.args.\r\n\t\tvar key, prop,\r\n\t\t\tprops = [];\r\n\r\n\t\tif (typeof source === OBJECT) {\r\n\t\t\tfor (key in source) {\r\n\t\t\t\tprop = source[key];\r\n\t\t\t\tif (!prop || !prop.toJSON || prop.toJSON()) {\r\n\t\t\t\t\tif (!$isFunction(prop)) {\r\n\t\t\t\t\t\tprops.push({ key: key, prop: prop });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn props;\r\n\t}\r\n\r\n\t//========================== Register converters ==========================\r\n\r\n\tfunction htmlEncode(text) {\r\n\t\t// HTML encode: Replace < > & ' and \" by corresponding entities.\r\n\t\treturn text != undefined ? rIsHtml.test(text) && (\"\" + text).replace(rHtmlEncode, getCharEntity) || text : \"\";\r\n\t}\r\n\r\n\t$converters({\r\n\t\thtml: htmlEncode,\r\n\t\tattr: htmlEncode, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings\r\n\t\turl: function(text) {\r\n\t\t\t// URL encoding helper.\r\n\t\t\treturn text != undefined ? encodeURI(\"\" + text) : text === null ? text : \"\"; // null returns null, e.g. to remove attribute. undefined returns \"\"\r\n\t\t}\r\n\t});\r\n\r\n\t//========================== Define default delimiters ==========================\r\n\t$viewsDelimiters();\r\n\r\n\tif (typeof exports === \"object\") {\r\n\t\t// JsRender loaded as Browserify client bundle\r\n\t\tmodule.exports = $;\r\n\t}\r\n\r\n\treturn $;\r\n}));\r\n"],"sourceRoot":"/source/"}